{"ast":null,"code":"'use strict';\n/**\r\n * INTERNAL\r\n */\n\nconst identity = value => value;\n\nconst createReaction = type => payload => ({\n  type,\n  payload\n});\n\nconst isLetterInLowerCase = l => l.toLowerCase() === l;\n\nconst isLetterInUpperCase = l => !isLetterInLowerCase(l);\n\nconst isFunction = functionToCheck => functionToCheck && {}.toString.call(functionToCheck) === '[object Function]';\n\nconst domainInitialState = () => ({\n  allIds: [],\n  byId: {}\n});\n\nconst camelCaseToConstCase = str => {\n  let res = '';\n  let isPrevLetterInDowncase = false;\n\n  for (let l of str) {\n    if (isLetterInUpperCase(l) && isPrevLetterInDowncase) {\n      res += '_' + l;\n    } else {\n      res += l.toUpperCase();\n    }\n\n    isPrevLetterInDowncase = isLetterInLowerCase(l);\n  }\n\n  return res;\n};\n\nconst configureReducersDictionary = reducers => {\n  const dictionary = {};\n  let actionCreatorBuffer = [];\n  reducers.forEach(arg => {\n    if (arg.isActionCreator) {\n      actionCreatorBuffer.push(arg);\n    } else {\n      actionCreatorBuffer.forEach(currentActionCreator => {\n        dictionary[currentActionCreator.type] = arg;\n      });\n      actionCreatorBuffer = [];\n    }\n  });\n  return dictionary;\n};\n/**\r\n * FOR EXPORT:\r\n */\n\n/**\r\n * PREPARATION\r\n */\n\n/**\r\n * Creates the main function: wrap. Example: const store = wrap(configureStore()).\r\n */\n\n\nexport const createWrap = () => {\n  const dispatchProvider = {\n    dispatch: null\n  };\n\n  const wrap = store => {\n    dispatchProvider.dispatch = store.dispatch;\n    return store;\n  };\n\n  wrap.dispatchProvider = dispatchProvider;\n  return wrap;\n};\n/**\r\n * ACTIONS\r\n */\n\n/**\r\n * A reactions creator factory wrapping by dispatch.\r\n * formatter takes only a word with a-zA-Z$_0-9 symbols.\r\n */\n\nexport const reactions = (wrap, childrenNames = [], config) => {\n  const _formatter$separator$ = {\n    formatter: camelCaseToConstCase,\n    separator: '_',\n    reactionSet: [],\n    ...config\n  },\n        formatter = _formatter$separator$.formatter,\n        separator = _formatter$separator$.separator,\n        reactionSet = _formatter$separator$.reactionSet;\n  childrenNames.forEach(childName => {\n    reactionSet[childName] = [];\n  });\n  return new Proxy({}, {\n    get(_, prop) {\n      const propForLog = formatter(prop);\n      const reactionCreator = createReaction(propForLog);\n\n      const dispatchReaction = (...args) => wrap.dispatchProvider.dispatch(reactionCreator(...args));\n\n      dispatchReaction.type = propForLog;\n      dispatchReaction.isActionCreator = true;\n      reactionSet.push(dispatchReaction);\n      childrenNames.forEach(name => {\n        const childPropForLog = propForLog + separator + formatter(name);\n        const childReactionCreator = createReaction(childPropForLog);\n\n        dispatchReaction[name] = (...args) => wrap.dispatchProvider.dispatch(childReactionCreator(...args));\n\n        dispatchReaction[name].type = childPropForLog;\n        dispatchReaction[name].isActionCreator = true;\n        reactionSet[name].push(dispatchReaction[name]);\n      });\n      return dispatchReaction;\n    }\n\n  });\n};\nexport const createReactionSet = () => [];\n/**\r\n * REDUCERS\r\n */\n\nexport const createReducer = initialStateOrInitFunction => (...args) => {\n  const initialState = isFunction(initialStateOrInitFunction) ? initialStateOrInitFunction(domainInitialState()) : initialStateOrInitFunction;\n  const dictionary = configureReducersDictionary(args);\n  return (state = initialState, action) => {\n    const handler = dictionary[action.type];\n    if (!handler) return state;\n    if (!isFunction(handler)) return handler;\n    const newSlice = handler(state, action);\n    if (isFunction(newSlice)) return newSlice();\n    return { ...state,\n      ...newSlice\n    };\n  };\n};\n/**\r\n * SELECTORS\r\n */\n\nconst BY_ID = 'byId';\nexport const createSelect = (getSubState = identity) => {\n  const all = getSubState;\n\n  const defineProperty = (key, value) => Object.defineProperty(all, key, {\n    value\n  });\n\n  return [initialState => {\n    const keys = Object.keys(initialState);\n    keys.forEach(key => {\n      switch (key) {\n        case BY_ID:\n          defineProperty(key, (state, id) => {\n            const entity = getSubState(state)[key][id]; // check for null and undefined\n\n            return entity == null ? {} : entity;\n          });\n          break;\n\n        default:\n          defineProperty(key, state => getSubState(state)[key]);\n      }\n    });\n    return initialState;\n  }, all];\n};","map":{"version":3,"sources":["/home/olof/sata-hakaton/node_modules/redux-from-void/index.js"],"names":["identity","value","createReaction","type","payload","isLetterInLowerCase","l","toLowerCase","isLetterInUpperCase","isFunction","functionToCheck","toString","call","domainInitialState","allIds","byId","camelCaseToConstCase","str","res","isPrevLetterInDowncase","toUpperCase","configureReducersDictionary","reducers","dictionary","actionCreatorBuffer","forEach","arg","isActionCreator","push","currentActionCreator","createWrap","dispatchProvider","dispatch","wrap","store","reactions","childrenNames","config","formatter","separator","reactionSet","childName","Proxy","get","_","prop","propForLog","reactionCreator","dispatchReaction","args","name","childPropForLog","childReactionCreator","createReactionSet","createReducer","initialStateOrInitFunction","initialState","state","action","handler","newSlice","BY_ID","createSelect","getSubState","all","defineProperty","key","Object","keys","id","entity"],"mappings":"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","sourcesContent":["'use strict'\r\n\r\n\r\n/**\r\n * INTERNAL\r\n */\r\n\r\nconst identity = value => value\r\nconst createReaction = type => payload => ({ type, payload })\r\n\r\nconst isLetterInLowerCase = l => l.toLowerCase() === l\r\nconst isLetterInUpperCase = l => !isLetterInLowerCase(l)\r\nconst isFunction = functionToCheck => functionToCheck && {}.toString.call(functionToCheck) === '[object Function]'\r\nconst domainInitialState = () => ({ allIds: [], byId: {} })\r\n\r\nconst camelCaseToConstCase = str => {\r\n    let res = ''\r\n\r\n    let isPrevLetterInDowncase = false\r\n    for (let l of str){\r\n        if (isLetterInUpperCase(l) && isPrevLetterInDowncase) {\r\n            res += ('_' + l)\r\n        } else {\r\n            res += l.toUpperCase()\r\n        }\r\n\r\n        isPrevLetterInDowncase = isLetterInLowerCase(l)\r\n    }\r\n\r\n    return res\r\n}\r\n\r\nconst configureReducersDictionary = reducers => {\r\n    const dictionary = {}\r\n    let actionCreatorBuffer = []\r\n\r\n    reducers.forEach(arg => {\r\n        if (arg.isActionCreator) {\r\n\r\n            actionCreatorBuffer.push(arg)\r\n        } else {\r\n\r\n            actionCreatorBuffer.forEach(currentActionCreator => {\r\n                dictionary[currentActionCreator.type] = arg\r\n            });\r\n            actionCreatorBuffer = []\r\n        }\r\n    })\r\n\r\n    return dictionary\r\n}\r\n\r\n/**\r\n * FOR EXPORT:\r\n */\r\n\r\n/**\r\n * PREPARATION\r\n */\r\n\r\n/**\r\n * Creates the main function: wrap. Example: const store = wrap(configureStore()).\r\n */\r\nexport const createWrap = () => {\r\n    const dispatchProvider = {\r\n        dispatch: null\r\n    }\r\n\r\n    const wrap = store => {\r\n        dispatchProvider.dispatch = store.dispatch\r\n        return store\r\n    }\r\n\r\n    wrap.dispatchProvider = dispatchProvider\r\n\r\n    return wrap\r\n}\r\n\r\n\r\n/**\r\n * ACTIONS\r\n */\r\n\r\n/**\r\n * A reactions creator factory wrapping by dispatch.\r\n * formatter takes only a word with a-zA-Z$_0-9 symbols.\r\n */\r\nexport const reactions = (\r\n    wrap,\r\n    childrenNames = [],\r\n    config\r\n) => {\r\n    const { formatter, separator, reactionSet } = {\r\n        formatter: camelCaseToConstCase,\r\n        separator: '_',\r\n        reactionSet: [],\r\n        ...config,\r\n    }\r\n    childrenNames.forEach(childName => {\r\n        reactionSet[ childName ] = []\r\n    })\r\n\r\n    return new Proxy({}, {\r\n        get(_, prop) {\r\n            const propForLog = formatter(prop)\r\n            const reactionCreator = createReaction(propForLog)\r\n\r\n            const dispatchReaction = (...args) => wrap.dispatchProvider.dispatch(reactionCreator(...args))\r\n            dispatchReaction.type = propForLog\r\n            dispatchReaction.isActionCreator = true\r\n\r\n            reactionSet.push(dispatchReaction)\r\n\r\n            childrenNames.forEach(name => {\r\n                const childPropForLog = propForLog + separator + formatter(name)\r\n                const childReactionCreator = createReaction(childPropForLog)\r\n\r\n                dispatchReaction[name] = (...args) => wrap.dispatchProvider.dispatch(childReactionCreator(...args))\r\n                dispatchReaction[name].type = childPropForLog\r\n                dispatchReaction[name].isActionCreator = true\r\n\r\n                reactionSet[name].push(dispatchReaction[name])\r\n            })\r\n\r\n            return dispatchReaction\r\n        }\r\n    })\r\n}\r\n\r\nexport const createReactionSet = () => []\r\n\r\n\r\n/**\r\n * REDUCERS\r\n */\r\n\r\nexport const createReducer = (initialStateOrInitFunction) => (...args) => {\r\n    const initialState = isFunction(initialStateOrInitFunction)\r\n        ? initialStateOrInitFunction(domainInitialState())\r\n        : initialStateOrInitFunction\r\n    const dictionary = configureReducersDictionary(args)\r\n\r\n    return (state = initialState, action) => {\r\n        const handler = dictionary[action.type]\r\n\r\n        if (!handler)\r\n            return state\r\n\r\n        if (!isFunction(handler))\r\n            return handler\r\n\r\n        const newSlice = handler(state, action)\r\n\r\n        if (isFunction(newSlice))\r\n            return newSlice()\r\n\r\n        return {\r\n            ...state,\r\n            ...newSlice\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * SELECTORS\r\n */\r\n\r\nconst BY_ID = 'byId'\r\n\r\nexport const createSelect = (getSubState = identity) => {\r\n    const all = getSubState\r\n    const defineProperty = (key, value) => Object.defineProperty(all, key, { value })\r\n\r\n    return [\r\n        initialState => {\r\n            const keys = Object.keys(initialState)\r\n\r\n            keys.forEach(key => {\r\n                switch (key) {\r\n                    case BY_ID:\r\n                        defineProperty(key, (state, id) => {\r\n                            const entity = getSubState(state)[ key ][ id ]\r\n\r\n                            // check for null and undefined\r\n                            return entity == null ? {} : entity\r\n                        })\r\n                        break\r\n                    default:\r\n                        defineProperty(key, state => getSubState(state)[ key ])\r\n                }\r\n            })\r\n\r\n            return initialState\r\n        },\r\n        all\r\n    ]\r\n}"]},"metadata":{},"sourceType":"module"}