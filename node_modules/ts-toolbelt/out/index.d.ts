declare module "Number/Number" {
    /** Describes what a [[Number]] is
     */
    export type Number = string;
}
declare module "Iteration/IterationOf" {
    import { Number } from "Number/Number";
    /** Describes a map of number relationships
     * (Generated with "./_Internal/IterationOfGenerator")
     * @hidden
     */
    export type IterationMap = {
        '-40': ['__', '-39', '-40', -40, '-'];
        '-39': ['-40', '-38', '-39', -39, '-'];
        '-38': ['-39', '-37', '-38', -38, '-'];
        '-37': ['-38', '-36', '-37', -37, '-'];
        '-36': ['-37', '-35', '-36', -36, '-'];
        '-35': ['-36', '-34', '-35', -35, '-'];
        '-34': ['-35', '-33', '-34', -34, '-'];
        '-33': ['-34', '-32', '-33', -33, '-'];
        '-32': ['-33', '-31', '-32', -32, '-'];
        '-31': ['-32', '-30', '-31', -31, '-'];
        '-30': ['-31', '-29', '-30', -30, '-'];
        '-29': ['-30', '-28', '-29', -29, '-'];
        '-28': ['-29', '-27', '-28', -28, '-'];
        '-27': ['-28', '-26', '-27', -27, '-'];
        '-26': ['-27', '-25', '-26', -26, '-'];
        '-25': ['-26', '-24', '-25', -25, '-'];
        '-24': ['-25', '-23', '-24', -24, '-'];
        '-23': ['-24', '-22', '-23', -23, '-'];
        '-22': ['-23', '-21', '-22', -22, '-'];
        '-21': ['-22', '-20', '-21', -21, '-'];
        '-20': ['-21', '-19', '-20', -20, '-'];
        '-19': ['-20', '-18', '-19', -19, '-'];
        '-18': ['-19', '-17', '-18', -18, '-'];
        '-17': ['-18', '-16', '-17', -17, '-'];
        '-16': ['-17', '-15', '-16', -16, '-'];
        '-15': ['-16', '-14', '-15', -15, '-'];
        '-14': ['-15', '-13', '-14', -14, '-'];
        '-13': ['-14', '-12', '-13', -13, '-'];
        '-12': ['-13', '-11', '-12', -12, '-'];
        '-11': ['-12', '-10', '-11', -11, '-'];
        '-10': ['-11', '-9', '-10', -10, '-'];
        '-9': ['-10', '-8', '-9', -9, '-'];
        '-8': ['-9', '-7', '-8', -8, '-'];
        '-7': ['-8', '-6', '-7', -7, '-'];
        '-6': ['-7', '-5', '-6', -6, '-'];
        '-5': ['-6', '-4', '-5', -5, '-'];
        '-4': ['-5', '-3', '-4', -4, '-'];
        '-3': ['-4', '-2', '-3', -3, '-'];
        '-2': ['-3', '-1', '-2', -2, '-'];
        '-1': ['-2', '0', '-1', -1, '-'];
        '0': ['-1', '1', '0', 0, '0'];
        '1': ['0', '2', '1', 1, '+'];
        '2': ['1', '3', '2', 2, '+'];
        '3': ['2', '4', '3', 3, '+'];
        '4': ['3', '5', '4', 4, '+'];
        '5': ['4', '6', '5', 5, '+'];
        '6': ['5', '7', '6', 6, '+'];
        '7': ['6', '8', '7', 7, '+'];
        '8': ['7', '9', '8', 8, '+'];
        '9': ['8', '10', '9', 9, '+'];
        '10': ['9', '11', '10', 10, '+'];
        '11': ['10', '12', '11', 11, '+'];
        '12': ['11', '13', '12', 12, '+'];
        '13': ['12', '14', '13', 13, '+'];
        '14': ['13', '15', '14', 14, '+'];
        '15': ['14', '16', '15', 15, '+'];
        '16': ['15', '17', '16', 16, '+'];
        '17': ['16', '18', '17', 17, '+'];
        '18': ['17', '19', '18', 18, '+'];
        '19': ['18', '20', '19', 19, '+'];
        '20': ['19', '21', '20', 20, '+'];
        '21': ['20', '22', '21', 21, '+'];
        '22': ['21', '23', '22', 22, '+'];
        '23': ['22', '24', '23', 23, '+'];
        '24': ['23', '25', '24', 24, '+'];
        '25': ['24', '26', '25', 25, '+'];
        '26': ['25', '27', '26', 26, '+'];
        '27': ['26', '28', '27', 27, '+'];
        '28': ['27', '29', '28', 28, '+'];
        '29': ['28', '30', '29', 29, '+'];
        '30': ['29', '31', '30', 30, '+'];
        '31': ['30', '32', '31', 31, '+'];
        '32': ['31', '33', '32', 32, '+'];
        '33': ['32', '34', '33', 33, '+'];
        '34': ['33', '35', '34', 34, '+'];
        '35': ['34', '36', '35', 35, '+'];
        '36': ['35', '37', '36', 36, '+'];
        '37': ['36', '38', '37', 37, '+'];
        '38': ['37', '39', '38', 38, '+'];
        '39': ['38', '40', '39', 39, '+'];
        '40': ['39', '__', '40', 40, '+'];
        '__': ['__', '__', string, number, '-' | '0' | '+'];
    };
    /** Transform a number into an [[Iteration]]
     * (to use [[Prev]], [[Next]], & [[Pos]])
     * @param N to transform
     * @returns [[Iteration]]
     * @example
     * ```ts
     * import {I} from 'ts-toolbelt'
     *
     * type i = I.IterationOf<'0'> // ["-1", "1", "0", 0, "0"]
     *
     * type next = I.Next<i>       // ["0", "2", "1", 1, "+"]
     * type prev = I.Prev<i>       // ["-2", "0", "-1", -1, "-"]
     *
     * type nnext = I.Pos<next>    // +1
     * type nprev = I.Pos<prev>    // -1
     * ```
     */
    export type IterationOf<N extends Number> = N extends keyof IterationMap ? IterationMap[N] : IterationMap['__'];
}
declare module "Iteration/Iteration" {
    import { IterationMap } from "Iteration/IterationOf";
    /** Describes a valid entry of **`IterationMap`**
     * * `[0]`: Prev (<-)
     * * `[1]`: Next (->)
     * * `[2]`: Current **`string`**
     * * `[3]`: Current **`number`**
     * * `[4]`: Sign (- / 0 / +)
     */
    export type Iteration = [keyof IterationMap, keyof IterationMap, string, number, '-' | '0' | '+'];
}
declare module "Iteration/Next" {
    import { IterationMap } from "Iteration/IterationOf";
    import { Iteration } from "Iteration/Iteration";
    /** Move **`I`**'s position forward
     * @param I to move
     * @returns [[Iteration]]
     * @example
     * ```ts
     * import {I} from 'ts-toolbelt'
     *
     * type i = I.IterationOf<'20'>
     *
     * type test0 = I.Pos<i>         // 20
     * type test1 = I.Pos<I.Next<i>> // 21
     * ```
     */
    export type Next<I extends Iteration> = IterationMap[I[1]];
}
declare module "List/List" {
    /** A [[List]]
     * @param A its type
     * @returns **`any[]`**
     * @example
     * ```ts
     * type list0 = [1, 2, 3]
     * type list1 = ['a', 42]
     * ```
     */
    export type List<A = any> = ReadonlyArray<A>;
}
declare module "List/Prepend" {
    import { List } from "List/List";
    /** Add an element **`A`** at the beginning of **`T`**
     * @param T to append to
     * @param A to be added to
     * @returns **`any[]`**
     * @example
     * ```ts
     * ```
     */
    export type Prepend<T extends List, A extends any> = ((head: A, ...args: T) => any) extends ((...args: infer U) => any) ? U : T;
}
declare module "Any/Cast" {
    /** Ask TS to re-check that **`A1`** extends **`A2`**.
     * And if it fails, **`A2`** will be enforced anyway.
     * Can also be used to add constraints on parameters.
     * @param A1 to check against
     * @param A2 to cast **`A1`** to
     * @returns **`A1`** or **`A2`**
     * @example
     * ```ts
     * import {A} from 'ts-toolbelt'
     *
     * type test0 = A.Cast<'42', string> // '42'
     * type test1 = A.Cast<'42', number> // number
     * ```
     */
    export type Cast<A1 extends any, A2 extends any> = A1 extends A2 ? A1 : A2;
}
declare module "Iteration/_Internal" {
    /** Describes compatible type formats
     * * `s`: **`string`**
     * * `n`: **`number`**
     */
    export type Formats = 'n' | 's';
    /** Describes how to perform iterations
     */
    export type Way = '->' | '<-';
}
declare module "Iteration/Format" {
    import { Iteration } from "Iteration/Iteration";
    import { Formats } from "Iteration/_Internal";
    /** Is [[Key]] and [[Pos]] in a single type
     * @param I to query
     * @param fmt output
     * @returns **`string | number`**
     * @example
     * ```ts
     * import {I} from 'ts-toolbelt'
     *
     * /// Let's make '20' an iteration
     * type i = I.IterationOf<'20'> // [...]
    
     * type fmtS = I.Fmt<i, 's'> // '20'
     * type fmtN = I.Fmt<i, 'n'> //  20
     * ```
     */
    export type Format<I extends Iteration, fmt extends Formats> = {
        's': I[2];
        'n': I[3];
    }[fmt];
}
declare module "Iteration/Key" {
    import { Iteration } from "Iteration/Iteration";
    import { Format } from "Iteration/Format";
    /** Get the position of **`I`** (**string**)
     * @param I to query
     * @returns **`string`**
     * @example
     * ```ts
     * import {I} from 'ts-toolbelt'
     *
     * type i = I.IterationOf<'20'>
     *
     * type test0 = I.Key<i>         // '20'
     * type test1 = I.Key<I.Next<i>> // '21'
     * ```
     */
    export type Key<I extends Iteration> = Format<I, 's'>;
}
declare module "List/Repeat" {
    import { Next } from "Iteration/Next";
    import { Prepend } from "List/Prepend";
    import { IterationOf } from "Iteration/IterationOf";
    import { Iteration } from "Iteration/Iteration";
    import { Number } from "Number/Number";
    import { Cast } from "Any/Cast";
    import { Key } from "Iteration/Key";
    import { List } from "List/List";
    /**
     * @hidden
     */
    type _Repeat<N extends Number, A, T extends List = [], I extends Iteration = IterationOf<'0'>> = {
        0: _Repeat<N, A, Prepend<T, A>, Next<I>>;
        1: T;
    }[N extends Key<I> ? 1 : 0];
    /** Fill a [[List]] with **`N`** times **`A`**
     * @param A to fill with
     * @param N to repeat it
     * @param T to be filled (?=[])
     * @returns **`any[]`**
     * @example
     * ```ts
     * ```
     */
    export type Repeat<A extends any, N extends Number, T extends List = []> = _Repeat<N, A, T> extends infer X ? Cast<X, List> : never;
}
declare module "Boolean/Boolean" {
    export type Boolean = True | False;
    export type True = 1;
    export type False = 0;
}
declare module "Any/Equals" {
    import { True, False } from "Boolean/Boolean";
    /** Check whether **`A1`** is equal to **`A2`** or not.
     * @param A1
     * @param A2
     * @returns [[Boolean]]
     * @example
     * ```ts
     * import {A} from 'ts-toolbelt'
     *
     * type test0 = A.Equals<42 | 0, 42 | 0>                    // true
     * type test1 = A.Equals<{a: string}, {b: string}>          // false
     * type test3 = A.Equals<{a: string}, {readonly a: string}> // false
     * ```
     */
    export type Equals<A1 extends any, A2 extends any> = (<A>() => A extends A1 ? True : False) extends (<A>() => A extends A2 ? True : False) ? True : False;
}
declare module "Any/Compute" {
    /** Force TS to load a type that has not been computed (to resolve composed
     * types that TS haven't fully resolved, for display purposes mostly).
     * @param A to compute
     * @returns **`A`**
     * @example
     * ```ts
     * import {A} from 'ts-toolbelt'
     *
     * type test0 = A.Compute<{x: 'x'} & {y: 'y'}> // {x: 'x', y: 'y'}
     * ```
     */
    export type Compute<A extends any> = A extends Function ? A : {
        [K in keyof A]: A[K];
    } & {};
}
declare module "Test" {
    import { Repeat } from "List/Repeat";
    import { Equals } from "Any/Equals";
    import { Compute } from "Any/Compute";
    import { True, False, Boolean } from "Boolean/Boolean";
    export type Pass = True;
    export type Fail = False;
    export function check<Type, Expect, Outcome extends Boolean, Strict extends Boolean = True>(debug?: Compute<Type>): Equals<Equals<Type, Expect>, Outcome>;
    export function checks(asserts: Partial<Repeat<Pass, '30'>>): void;
}
declare module "Any/Index" {
    /** Describes index keys for any type
     */
    export type Index = string | number | symbol;
}
declare module "Object/Pick" {
    import { Index } from "Any/Index";
    /**
     * @hidden
     */
    type _Pick<O extends object, K extends keyof O> = {
        [P in K]: O[P];
    } & {};
    /** Extract out of **`O`** the fields of key **`K`**
     * @param O to extract from
     * @param K to chose fields
     * @returns **`object`**
     * @example
     * ```ts
     * ```
     */
    export type Pick<O extends object, K extends Index> = _Pick<O, K & keyof O>;
}
declare module "Union/Exclude" {
    /** Remove **`M`** out of **`U`**
     * @param U to remove from
     * @param M to remove out
     * @returns [[Union]]
     * @example
     * ```ts
     * ```
     */
    export type Exclude<U extends any, M extends any> = U extends M ? never : U;
}
declare module "Object/Omit" {
    import { Pick } from "Object/Pick";
    import { Exclude } from "Union/Exclude";
    import { Index } from "Any/Index";
    /** Remove out of **`O`** the fields of key **`K`**
     * @param O to remove from
     * @param K to chose fields
     * @returns **`object`**
     * @example
     * ```ts
     * ```
     */
    export type Omit<O extends object, K extends Index> = Pick<O, Exclude<keyof O, K>>;
}
declare module "Object/At" {
    import { Index } from "Any/Index";
    /** Get in **`O`** the type of a field of key **`K`**
     * @param O to extract from
     * @param K **`keyof`** to extract at
     * @returns **`any`**
     * @example
     * ```ts
     * import {O} from 'ts-toolbelt'
     *
     * type User = {
     *     info: {
     *         name: string
     *         age: number
     *         payment: {}
     *     }
     *     id: number
     * }
     *
     * type test0 = O.At<User, 'id'> // number
     * ```
     */
    export type At<O extends object, K extends Index> = K extends keyof O ? O[K] : never;
}
declare module "Number/_Internal" {
    import { IterationMap } from "Iteration/IterationOf";
    import { Format } from "Iteration/Format";
    /** Describes compatible type formats
     * * `b`: **`boolean`**
     * * `n`: **`number`**
     * * `s`: **`string`**
     */
    export type Formats = 'b' | 'n' | 's';
    /**
     * @hidden
     */
    type KnownIterationMapKeys = '-40' | '-39' | '-38' | '-37' | '-36' | '-35' | '-34' | '-33' | '-32' | '-31' | '-30' | '-29' | '-28' | '-27' | '-26' | '-25' | '-24' | '-23' | '-22' | '-21' | '-20' | '-19' | '-18' | '-17' | '-16' | '-15' | '-14' | '-13' | '-12' | '-11' | '-10' | '-9' | '-8' | '-7' | '-6' | '-5' | '-4' | '-3' | '-2' | '-1' | '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' | '10' | '11' | '12' | '13' | '14' | '15' | '16' | '17' | '18' | '19' | '20' | '21' | '22' | '23' | '24' | '25' | '26' | '27' | '28' | '29' | '30' | '31' | '32' | '33' | '34' | '35' | '36' | '37' | '38' | '39' | '40';
    /**
     * @hidden
     */
    type PositiveIterationKeys = '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' | '10' | '11' | '12' | '13' | '14' | '15' | '16' | '17' | '18' | '19' | '20' | '21' | '22' | '23' | '24' | '25' | '26' | '27' | '28' | '29' | '30' | '31' | '32' | '33' | '34' | '35' | '36' | '37' | '38' | '39' | '40';
    /**
     * @hidden
     */
    type NegativeIterationKeys = '-40' | '-39' | '-38' | '-37' | '-36' | '-35' | '-34' | '-33' | '-32' | '-31' | '-30' | '-29' | '-28' | '-27' | '-26' | '-25' | '-24' | '-23' | '-22' | '-21' | '-20' | '-19' | '-18' | '-17' | '-16' | '-15' | '-14' | '-13' | '-12' | '-11' | '-10' | '-9' | '-8' | '-7' | '-6' | '-5' | '-4' | '-3' | '-2' | '-1';
    /** Describes known values of a **number**
     * @hidden
     */
    export type Numbers = {
        'string': {
            'all': Format<IterationMap[KnownIterationMapKeys], 's'>;
            '+': Format<IterationMap[PositiveIterationKeys], 's'>;
            '-': Format<IterationMap[NegativeIterationKeys], 's'>;
            '0': Format<IterationMap['0'], 's'>;
        };
        'number': {
            'all': Format<IterationMap[KnownIterationMapKeys], 'n'>;
            '+': Format<IterationMap[PositiveIterationKeys], 'n'>;
            '-': Format<IterationMap[NegativeIterationKeys], 'n'>;
            '0': Format<IterationMap['0'], 'n'>;
        };
    };
}
declare module "Iteration/Pos" {
    import { Iteration } from "Iteration/Iteration";
    import { Format } from "Iteration/Format";
    /** Get the position of **`I`** (**number**)
     * @param I to query
     * @returns **`number`**
     * @example
     * ```ts
     * import {I} from 'ts-toolbelt'
     *
     * type i = I.IterationOf<'20'>
     *
     * type test0 = I.Pos<i>         // 20
     * type test1 = I.Pos<I.Next<i>> // 21
     * ```
     */
    export type Pos<I extends Iteration> = Format<I, 'n'>;
}
declare module "Number/NumberOf" {
    import { IterationMap } from "Iteration/IterationOf";
    import { Key } from "Iteration/Key";
    import { Pos } from "Iteration/Pos";
    import { Numbers } from "Number/_Internal";
    /**
     * @hidden
     */
    export type _NumberOf<N extends number> = {
        [K in keyof IterationMap]: Pos<IterationMap[K]> extends N ? Key<IterationMap[K]> : never;
    }[keyof IterationMap];
    /** Transform a **`number`** into a [[Number]]
     * @param N to stringify
     * @returns **`string`**
     * @example
     * ```ts
     * import {N} from 'ts-toolbelt'
     *
     * type test0 = N.StringOf<5>  //  '5'
     * type test1 = N.StringOf<-5> // '-5'
     * ```
     */
    export type NumberOf<N extends number> = N extends Numbers['number']['all'] ? _NumberOf<N> : string;
}
declare module "List/Length" {
    import { NumberOf } from "Number/NumberOf";
    import { Formats } from "Iteration/_Internal";
    import { List } from "List/List";
    /** Get the length of **`T`**
     * @param T to get length
     * @param fmt output (?=`'n'`)
     * @returns **`string`** or **`number`**
     * @example
     * ```ts
     * ```
     */
    export type Length<T extends List, fmt extends Formats = 'n'> = {
        's': NumberOf<T['length']>;
        'n': T['length'];
    }[fmt];
}
declare module "Object/Overwrite" {
    /** Update the fields of **`O`** with the ones of **`O1`**
     * (only the existing fields will be updated)
     * @param O to update
     * @param O1 to update with
     * @returns **`object`**
     * @example
     * ```ts
     * ```
     */
    export type Overwrite<O extends object, O1 extends object> = {
        [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
    } & {};
}
declare module "List/Overwrite" {
    import { Overwrite as OOverwrite } from "Object/Overwrite";
    import { Cast } from "Any/Cast";
    import { List } from "List/List";
    /** Update the entries of **`T`** with the ones of **`T1`**
     * @param T to update
     * @param T1 to update with
     * @returns **`object`**
     * @example
     * ```ts
     * ```
     */
    export type Overwrite<T extends List, T1 extends object> = Cast<OOverwrite<T, T1>, List>;
}
declare module "Object/_Internal" {
    /** Describes the permissions/modifiers fields can have
     * * `R`: readonly
     * * `W`: writable
     * * `!`: required
     * * `?`: optional
     */
    export type Modx = ['?' | '!', 'W' | 'R'];
    /** Describes the depth strategy when modifying types
     */
    export type Depth = 'flat' | 'deep';
}
declare module "Any/Extends" {
    import { False, True } from "Boolean/Boolean";
    /** Check whether **`A1`** is part of **`A2`** or not. The difference with
     * `extends` is that it forces a [[Boolean]] return.
     * @param A1
     * @param A2
     * @returns [[Boolean]]
     * @example
     * ```ts
     * import {A} from 'ts-toolbelt'
     *
     * type test0 = A.Extends<'a' | 'b', 'b'> // Boolean
     * type test1 = A.Extends<'a', 'a' | 'b'> // True
     *
     * type test2 = A.Extends<{a: string}, {a: any}>      // True
     * type test3 = A.Extends<{a: any}, {a: any, b: any}> // False
     *
     * type test4 = A.Extends<never, never> // False
     * /// Nothing cannot extend nothing, use `A.Equals`
     * ```
     */
    export type Extends<A1 extends any, A2 extends any> = [A1] extends [never] ? False : A1 extends A2 ? True : False;
}
declare module "Any/Kind" {
    import { Extends } from "Any/Extends";
    import { True } from "Boolean/Boolean";
    import { List } from "List/List";
    /** Get the literal kind of a type
     * @param A
     * @returns **`'string' | 'number' | 'function' | 'array' | 'object' | 'boolean'`**
     * @example
     * ```ts
     * ```
     */
    export type Kind<A extends any> = Extends<A, Function> extends True ? 'function' : Extends<A, List> extends True ? 'array' : Extends<A, object> extends True ? 'object' : Extends<A, string> extends True ? 'string' : Extends<A, number> extends True ? 'number' : Extends<A, boolean> extends True ? 'boolean' : 'unknown';
}
declare module "Object/Merge" {
    import { Omit } from "Object/Omit";
    import { At } from "Object/At";
    import { Compute } from "Any/Compute";
    import { Depth } from "Object/_Internal";
    import { Kind } from "Any/Kind";
    /**
     * @hidden
     */
    type MergeFlat<O extends object, O1 extends object> = Compute<O & Omit<O1, keyof O>>;
    /**
     * @hidden
     */
    type MergeDeep<O, O1> = (Kind<(O | O1)> extends 'object' ? MergeFlat<O & {}, O1 & {}> extends infer M ? {
        [K in keyof M]: MergeDeep<M[K], At<O1 & {}, K>>;
    } & {} : never : O);
    /** Complete the fields of **`O`** with the ones of **`O1`**
     * ('deep' option will skip nullable objects to be merged).
     * For more advanced capabilities, see [[MergeUp]].
     * @param O to complete
     * @param O1 to copy from
     * @param depth to do it deeply (?=`'flat'`)
     * @returns **`object`**
     * @example
     * ```ts
     * ```
     */
    export type Merge<O extends object, O1 extends object, depth extends Depth = 'flat'> = {
        'flat': MergeFlat<O, O1>;
        'deep': MergeDeep<O, O1>;
    }[depth];
}
declare module "Any/Implements" {
    import { False, True } from "Boolean/Boolean";
    import { Extends } from "Any/Extends";
    /** Check whether **`A1`** is part of **`A2`** or not. It works like
     * [[Extends]] but [[Boolean]] results are narrowed to [[False]].
     * @param A1
     * @param A2
     * @returns [[Boolean]]
     * @example
     * ```ts
     * type test0 = A.Implements<'a' | 'b', 'b'> // False
     * type test1 = A.Implements<'a', 'a' | 'b'> // True
     *
     * type test2 = A.Implements<{a: string}, {a: any}>      // True
     * type test3 = A.Implements<{a: any}, {a: any, b: any}> // False
     *
     * type test4 = A.Implements<never, never> // False
     * /// Nothing cannot implement nothing, use `A.Equals`
     * ```
     */
    export type Implements<A1 extends any, A2 extends any> = Extends<A1, A2> extends True ? True : False;
}
declare module "Object/Required" {
    import { Merge } from "Object/Merge";
    import { Pick } from "Object/Pick";
    import { Depth } from "Object/_Internal";
    import { Index } from "Any/Index";
    import { Implements } from "Any/Implements";
    /**
     * @hidden
     */
    type RequiredFlat<O> = {
        [K in keyof O]-?: O[K];
    } & {};
    /**
     * @hidden
     */
    type RequiredDeep<O> = {
        [K in keyof O]-?: RequiredDeep<O[K]>;
    };
    /**
     * @hidden
     */
    type RequiredPart<O extends object, depth extends Depth> = {
        'flat': RequiredFlat<O>;
        'deep': RequiredDeep<O>;
    }[depth];
    /** Make some fields of **`O`** required (deeply or not)
     * @param O to make required
     * @param K to choose fields (?=`keyof O`)
     * @param depth to do it deeply (?=`'flat'`)
     * @returns **`object`**
     * @example
     * ```ts
     * ```
     */
    export type Required<O extends object, K extends Index = keyof O, depth extends Depth = 'flat'> = {
        1: RequiredPart<O, depth>;
        0: Merge<RequiredPart<Pick<O, K>, depth>, O>;
    }[Implements<keyof O, K>];
}
declare module "List/Required" {
    import { Depth } from "Object/_Internal";
    import { Required as ORequired } from "Object/Required";
    import { Cast } from "Any/Cast";
    import { List } from "List/List";
    /** Make **`T`** required (deeply or not)
     * @param T to make required
     * @param depth to do it deeply (?=`'flat'`)
     * @returns **`any[]`**
     * @example
     * ```ts
     * ```
     */
    export type Required<T extends List, depth extends Depth = 'flat'> = Cast<ORequired<T, keyof T, depth>, List>;
}
declare module "List/Reverse" {
    import { Prepend } from "List/Prepend";
    import { Pos } from "Iteration/Pos";
    import { Next } from "Iteration/Next";
    import { Length } from "List/Length";
    import { IterationOf } from "Iteration/IterationOf";
    import { Iteration } from "Iteration/Iteration";
    import { Cast } from "Any/Cast";
    import { List } from "List/List";
    import { Overwrite } from "List/Overwrite";
    import { Required } from "List/Required";
    /**
     * @hidden
     */
    type _Reverse<T extends List, TO extends List, I extends Iteration = IterationOf<'0'>> = {
        0: _Reverse<T, Prepend<TO, T[Pos<I>]>, Next<I>>;
        1: TO;
    }[Pos<I> extends Length<T> ? 1 : 0];
    /** Turn a [[List]] the other way around
     * @param T to reverse
     * @param TO to append to (?=[])
     * @returns **`any[]`**
     * @example
     * ```ts
     * ```
     */
    export type Reverse<T extends List, TO extends List = []> = _Reverse<Overwrite<Required<T>, T>, TO> extends infer X ? Cast<X, List> : never;
}
declare module "List/Concat" {
    import { Reverse } from "List/Reverse";
    import { List } from "List/List";
    /** Attach **`T1`** at the end of **`T`**
     * @param T to concat with
     * @param T1 to be attached
     * @returns **`any[]`**
     * @example
     * ```ts
     * ```
     */
    export type Concat<T extends List, T1 extends List> = Reverse<Reverse<T>, T1>;
}
declare module "List/Append" {
    import { Concat } from "List/Concat";
    import { List } from "List/List";
    /** Add an element **`A`** at the end of **`T`**
     * @param T to append to
     * @param A to be added to
     * @returns **`any[]`**
     * @example
     * ```ts
     * ```
     */
    export type Append<T extends List, A extends any> = Concat<T, [A]>;
}
declare module "Object/ListOf" {
    import { IterationOf } from "Iteration/IterationOf";
    import { Iteration } from "Iteration/Iteration";
    import { Cast } from "Any/Cast";
    import { Key } from "Iteration/Key";
    import { Next } from "Iteration/Next";
    import { Append } from "List/Append";
    import { Exclude } from "Union/Exclude";
    import { List } from "List/List";
    /**
     * @hidden
     */
    type PickIfEntry<O extends object, TN extends List, I extends Iteration> = Key<I> extends keyof O ? Append<TN, O[Cast<Key<I>, keyof O>]> : TN;
    /**
     * @hidden
     */
    type _ListOf<O extends object, K, TN extends List = [], I extends Iteration = IterationOf<'0'>> = {
        0: _ListOf<O, Exclude<K, Key<I>>, PickIfEntry<O, TN, I>, Next<I>>;
        1: TN;
    }[[K] extends [never] ? 1 : 0];
    /** Transform an **`object`** into a [[List]]
     * (It will only pick numeric literal indexes)
     * @param O to transform
     * @param LastK last index to pick
     * @returns **`any[]`**
     * @example
     * ```ts
     * ```
     */
    export type ListOf<O extends object> = _ListOf<O, keyof O> extends infer X ? Cast<X, List> : never;
}
declare module "Union/HasAll" {
    import { True, False } from "Boolean/Boolean";
    /** Check whether **`U`** contains the whole union **`U1`**
     * @param U to be inspected
     * @param U1 to check within
     * @returns [[Boolean]]
     * @example
     * ```ts
     * ```
     */
    export type HasAll<U extends any, U1 extends any> = [Exclude<U1, U & U1>] extends [never] ? True : False;
}
declare module "Any/Clean" {
    import { Omit } from "Object/Omit";
    import { Pick } from "Object/Pick";
    import { At } from "Object/At";
    import { Exclude } from "Union/Exclude";
    import { Numbers } from "Number/_Internal";
    import { ListOf } from "Object/ListOf";
    import { True } from "Boolean/Boolean";
    import { HasAll } from "Union/HasAll";
    type ArrayEntry = Numbers['string']['0' | '+'];
    type ArrayProps = keyof any[] | ArrayEntry;
    /** Sometimes, we can end up with mixed up **`objects`** that do not make sense
     * visually (or that could at least be simplified for the end user). This will
     * turn anything that is passed to it into a cleaned up **`object`**.
     *
     * @param O
     * @returns **`object`**
     * @example
     * ```ts
     * ```
     */
    export type Clean<A extends any> = A extends object ? HasAll<keyof A, keyof any[]> extends True ? [Exclude<keyof A, ArrayProps>] extends [never] ? number extends At<A, 'length'> ? At<A, number>[] : A : number extends At<A, 'length'> ? Omit<A, ArrayProps> & At<A, number>[] : At<A, 'length'> extends number ? Omit<A, ArrayProps> & ListOf<Pick<A, ArrayEntry>> : A : A : A;
}
declare module "Any/_Internal" {
    /** Describes the match strategy when matching types
     * * `default`   : `extends->`
     * * `contains->`: X contains Y
     * * `extends->` : X extends  Y
     * * `<-contains`: Y contains X
     * * `<-extends` : Y extends  X
     * * `equals`    : X equals   Y
     */
    export type Match = 'default' | 'implements->' | '<-implements' | 'extends->' | '<-extends' | 'equals';
}
declare module "Any/Is" {
    import { Match } from "Any/_Internal";
    import { Extends } from "Any/Extends";
    import { Equals } from "Any/Equals";
    import { Implements } from "Any/Implements";
    /** Check whether `A` is similar to `A1` or not. In other words, it is a compact
     * type that bundles `Equals`, `Extends` and `Implements` comparison types.
     * @param A to be compared
     * @param A1 to compare to
     * @param match to change precision (?=`'default'`)
     * @returns [[Boolean]]
     * @example
     * ```ts
     * import {A} from 'ts-toolbelt'
     *
     * type test0 = A.Is<'a', 'a' | 'b', 'extends->'> // True
     * type test1 = A.Is<'a' | 'b', 'a', 'extends->'> // Boolean
     *
     * type test2 = A.Is<'a', 'a' | 'b', '<-extends'> // Boolean
     * type test3 = A.Is<'a' | 'b', 'a', '<-extends'> // True
     *
     * type test4 = A.Is<'a', 'a' | 'b', 'implements->'> // True
     * type test5 = A.Is<'a' | 'b', 'a', 'implements->'> // False
     *
     * type test6 = A.Is<'a', 'a' | 'b', '<-implements'> // False
     * type test7 = A.Is<'a' | 'b', 'a', '<-implements'> // True
     *
     * type test8 = A.Is<'a', 'a' | 'b', 'equals'>      // False
     * type test9 = A.Is<'b' |'a', 'a' | 'b', 'equals'> // True
     * ```
     */
    export type Is<A extends any, A1 extends any, match extends Match = 'default'> = {
        'default': Extends<A, A1>;
        'implements->': Implements<A, A1>;
        'extends->': Extends<A, A1>;
        '<-implements': Implements<A1, A>;
        '<-extends': Extends<A1, A>;
        'equals': Equals<A1, A>;
    }[match];
}
declare module "Any/Try" {
    /** Similar to [[Cast]] but with a custom fallback **`Catch`**. If it fails,
     * it will enforce **`Catch`** instead of **`A2`**.
     * @param A1 to check against
     * @param A2 to try **`A1`** with
     * @param Catch to fallback (fail)
     * @returns **`A1`** or **`Catch`**
     * @example
     * ```ts
     * import {A} from 'ts-toolbelt'
     *
     * type test0 = A.Try<'42', string>          // '42'
     * type test1 = A.Try<'42', number>          // never
     * type test1 = A.Try<'42', number, 'tried'> // 'tried'
     * ```
     */
    export type Try<A1 extends any, A2 extends any, Catch = never> = A1 extends A2 ? A1 : Catch;
}
declare module "Any/Type" {
    /** Create your own named sub-type from a type **`A`**
     * @param A to be personalized
     * @param Id to name the sub-type
     * @returns A new type **`Type<A, Name>`**
     * @example
     * ```ts
     * import {A} from 'ts-toolbelt'
     *
     * type EUR = Type<number, 'eur'>
     * type USD = Type<number, 'usd'>
     *
     * let eurWallet = 10 as EUR
     * let usdWallet = 15 as USD
     *
     * eurWallet = usdWallet // error
     * ```
     */
    export type Type<A extends any, Id extends string> = A & {
        __type: Id;
    };
}
declare module "Any/x" {
    import { Type } from "Any/Type";
    /** A placeholder that is used in various ways
     */
    export type x = Type<'x', 'x'>;
}
declare module "Any/_api" {
    export { Cast } from "Any/Cast";
    export { Clean } from "Any/Clean";
    export { Compute } from "Any/Compute";
    export { Equals } from "Any/Equals";
    export { Extends } from "Any/Extends";
    export { Implements } from "Any/Implements";
    export { Index } from "Any/Index";
    export { Is } from "Any/Is";
    export { Kind } from "Any/Kind";
    export { Try } from "Any/Try";
    export { Type } from "Any/Type";
    export { x } from "Any/x";
}
declare module "Boolean/And" {
    import { Boolean, False, True } from "Boolean/Boolean";
    /** Logical **`&&`** operator (behaves like the JS one)
     * @param B1 Left-hand side
     * @param B2 Right-hand side
     * @returns [[Boolean]]
     * @example
     * ```ts
     * import {B} from 'ts-toolbelt'
     *
     * type test0 = B.And<B.True, B.False>          // False
     * type test1 = B.And<B.True, B.True>           // True
     * type test2 = B.And<B.True | B.False, B.True> // Boolean
     * ```
     */
    export type And<B1 extends Boolean, B2 extends Boolean> = {
        0: {
            0: False;
            1: False;
        };
        1: {
            0: False;
            1: True;
        };
    }[B1][B2];
}
declare module "Boolean/BooleanOf" {
    import { False, True } from "Boolean/Boolean";
    /** Transform a **`boolean`** into a [[Boolean]]
     * @param B to transform
     * @returns [[Boolean]]
     * @example
     * ```ts
     * type test0 = B.BooleanOf<true>  // 1
     * type test1 = B.BooleanOf<false> // 0
     * ```
     */
    export type BooleanOf<B extends boolean> = B extends true ? True : False;
}
declare module "Boolean/_Internal" {
    /** Describes compatible type formats
     * * `b`: **`boolean`**
     * * `n`: **`number`**
     * * `s`: **`string`**
     */
    export type Formats = 'b' | 'n' | 's';
}
declare module "Boolean/Format" {
    import { Boolean } from "Boolean/Boolean";
    import { Formats } from "Boolean/_Internal";
    /** Change the format of a [[Boolean]]
     * @param B to transform
     * @returns **`string | number | boolean`**
     * @example
     * ```ts
     * import {B} from 'ts-toolbelt'
     *
     * type test0 = B.Format<B.True, 's'> // 'true'
     * type test1 = B.Format<B.True, 'b'> //  true
     * ```
     */
    export type Format<B extends Boolean, fmt extends Formats> = {
        'b': [false, true][B];
        'n': B;
        's': ['false', 'true'][B];
    }[fmt];
}
declare module "Boolean/Not" {
    import { Boolean, False, True } from "Boolean/Boolean";
    /** Logical **`!`** operator (behaves like the JS one)
     * @param B to negate
     * @returns [[Boolean]]
     * @example
     * ```ts
     * import {B} from 'ts-toolbelt'
     *
     * type test0 = B.Not<B.True>  // False
     * type test1 = B.Not<B.False> // True
     * ```
     */
    export type Not<B extends Boolean> = {
        0: True;
        1: False;
    }[B];
}
declare module "Boolean/Or" {
    import { Boolean, False, True } from "Boolean/Boolean";
    /** Logical **`||`** operator (behaves like the JS one)
     * @param B1 Left-hand side
     * @param B2 Right-hand side
     * @returns [[Boolean]]
     * @example
     * ```ts
     * import {B} from 'ts-toolbelt'
     *
     * type test0 = B.Or<B.True, B.False>    // True
     * type test1 = B.Or<B.True, B.True>     // True
     * type test2 = B.Or<B.Boolean, B.False> // Boolean
     * ```
     */
    export type Or<B1 extends Boolean, B2 extends Boolean> = {
        0: {
            0: False;
            1: True;
        };
        1: {
            0: True;
            1: True;
        };
    }[B1][B2];
}
declare module "Boolean/Xor" {
    import { Boolean, False, True } from "Boolean/Boolean";
    /** Logical **`^`** operator (behaves like the JS one)
     * @param B1 Left-hand side
     * @param B2 Right-hand side
     * @returns [[Boolean]]
     * @example
     * ```ts
     * import {B} from 'ts-toolbelt'
     *
     * type test0 = B.Xor<B.True, B.True>    // False
     * type test1 = B.Xor<B.False, B.True>   // True
     * type test2 = B.Xor<B.Boolean, B.True> // Boolean
     * ```
     */
    export type Xor<B1 extends Boolean, B2 extends Boolean> = {
        0: {
            0: False;
            1: True;
        };
        1: {
            0: True;
            1: False;
        };
    }[B1][B2];
}
declare module "Boolean/_api" {
    export { And } from "Boolean/And";
    export { True, False, Boolean } from "Boolean/Boolean";
    export { BooleanOf } from "Boolean/BooleanOf";
    export { Format } from "Boolean/Format";
    export { Not } from "Boolean/Not";
    export { Or } from "Boolean/Or";
    export { Xor } from "Boolean/Xor";
}
declare module "Class/InstanceOf" {
    /** Get the instance type of a **`class`** from a class object
     * @param C **typeof** **`class`**
     * @returns **`class`**
     * @example
     * ```ts
     * import {C} from 'ts-toolbelt'
     *
     * /// `create` takes an instance constructor and creates an instance of it
     * declare function create<C extends (new (...args: any[]) => any)>(c: C): C.InstanceOf<C>
     *
     * class A {}
     * class B {}
     *
     * let a = create(A) // A
     * let b = create(B) // B
     * ```
     */
    export type InstanceOf<C extends new (...args: any[]) => any> = InstanceType<C>;
}
declare module "Class/Parameters" {
    /** Get the parameters of a class constructor
     * @param C **typeof** **`class`**
     * @returns **`any[]`**
     * @example
     * ```ts
     * ```
     */
    export type Parameters<C extends new (...args: any[]) => any> = C extends new (...args: infer P) => any ? P : never;
}
declare module "Class/PromiseOf" {
    /** Get the instance type wrapped within a **`Promise`**
     * @param P **`Promise`**
     * @returns **`any`**
     * @example
     * ```ts
     * import {C} from 'ts-toolbelt'
     *
     * const promise = new Promise<string>((res, rej) => res('x'))
     *
     * type test0 = C.PromiseOf<typeof promise>  // string
     * type test1 = C.PromiseOf<Promise<number>> // number
     * ```
     */
    export type PromiseOf<P extends any> = P extends Promise<infer A> ? A : P;
}
declare module "Class/_api" {
    export { InstanceOf } from "Class/InstanceOf";
    export { Parameters } from "Class/Parameters";
    export { PromiseOf } from "Class/PromiseOf";
}
declare module "Function/_Internal" {
    /** Describes function modes
     * * `sync`: Normal function
     * * `async`: Promise result
     */
    export type Mode = 'sync' | 'async';
    /**
     * @hidden
     */
    export type _Function = Function;
}
declare module "Function/Function" {
    import { _Function } from "Function/_Internal";
    import { List } from "List/List";
    /** Alias to create a [[Function]]
     * @param P parameters
     * @param R return type
     * @returns [[Function]]
     * @example
     * ```ts
     * import {F} from 'ts-toolbelt'
     *
     * type test0 = F.Function<[string, number], boolean>
     * /// (args_0: string, args_1: number) => boolean
     * ```
     */
    export type Function<P extends List = any, R extends any = any> = ((...args: P) => R) & _Function;
}
declare module "List/Tail" {
    import { List } from "List/List";
    /** Remove the first item out of a [[List]]
     * @param T
     * @returns **`any[]`**
     * @example
     * ```ts
     * ```
     */
    export type Tail<T extends List> = ((...t: T) => any) extends ((head: any, ...tail: infer TTail) => any) ? TTail : never;
}
declare module "List/Last" {
    import { Tail } from "List/Tail";
    import { Length } from "List/Length";
    import { List } from "List/List";
    /** Get the last entry of **`T`**
     * @param T to extract from
     * @returns **`any`**
     * @example
     * ```ts
     * ```
     */
    export type Last<T extends List> = T[Length<Tail<T>>];
}
declare module "String/_Internal" {
    /** Describes compatible type formats
     * * `b`: **`boolean`**
     * * `s`: **`string`**
     * * `n`: **`number`**
     */
    export type Formats = 'b' | 'n' | 's';
}
declare module "String/Format" {
    import { Formats } from "String/_Internal";
    import { Pos } from "Iteration/Pos";
    import { IterationOf } from "Iteration/IterationOf";
    import { False, True } from "Boolean/Boolean";
    import { Extends } from "Any/Extends";
    /** Change the format of a **`string`**
     * @param S to transform
     * @returns **`string | number | boolean`**
     * @example
     * ```ts
     * import {S} from 'ts-toolbelt'
     *
     * type test0 = S.Format<'30', 'b'> // True
     * type test1 = S.Format<'30', 'n'> // 30
     * ```
     */
    export type Format<S extends string, fmt extends Formats> = {
        'b': {
            1: Boolean;
            0: S extends 'false' ? False : True;
        }[Extends<string, S>];
        'n': Pos<IterationOf<S>>;
        's': S;
    }[fmt];
}
declare module "List/Head" {
    import { Length } from "List/Length";
    import { List } from "List/List";
    /** Get the first entry of **`T`**
     * @param T to extract from
     * @returns **`any`**
     * @example
     * ```ts
     * ```
     */
    export type Head<T extends List> = Length<T> extends 0 ? never : T[0];
}
declare module "Function/Return" {
    import { Function } from "Function/Function";
    /** Extract the return type of a [[Function]]
     * @param F to extract from
     * @returns **`any`**
     * @example
     * ```ts
     * import {F} from 'ts-toolbelt'
     *
     * const fn = () => true
     *
     * type test0 = F.ReturnOf<typeof fn>  // boolean
     *
     * type test1 = F.ReturnOf<() => true> // true
     * ```
     */
    export type Return<F extends Function> = F extends ((...args: any[]) => infer R) ? R : never;
}
declare module "Function/Parameters" {
    import { Function } from "Function/Function";
    /** Extract parameters from a [[Function]]
     * @param F to extract from
     * @returns **`any[]`**
     * @example
     * ```ts
     * import {F} from 'ts-toolbelt'
     *
     * const fn = (name: string, age: number) => {}
     *
     * type test0 = F.ParamsOf<typeof fn>                         // [string, number]
     *
     * type test1 = F.ParamsOf<(name: string, age: number) => {}> // [string, number]
     * ```
     */
    export type Parameters<F extends Function> = F extends ((...args: infer T) => any) ? T : never;
}
declare module "Function/Compose" {
    import { Function } from "Function/Function";
    import { Pos } from "Iteration/Pos";
    import { IterationOf } from "Iteration/IterationOf";
    import { Last } from "List/Last";
    import { Format } from "String/Format";
    import { Length } from "List/Length";
    import { Tail } from "List/Tail";
    import { Next } from "Iteration/Next";
    import { Head } from "List/Head";
    import { Return } from "Function/Return";
    import { Parameters } from "Function/Parameters";
    import { Mode } from "Function/_Internal";
    import { PromiseOf } from "Class/PromiseOf";
    import { Or } from "Boolean/Or";
    import { Extends } from "Any/Extends";
    import { List } from "List/List";
    /**
     * @hidden
     */
    type ComposeFnSync<Fns extends List<Function>, K extends keyof Fns> = Length<Tail<Fns>> extends Format<K & string, 'n'> ? Fns[K] : Function<[// handling unknown generics, waiting for proposal
    Return<Fns[Pos<Next<IterationOf<K & string>>>]> extends infer X ? {
        1: any;
        0: X;
    }[Or<Extends<unknown, X>, Extends<unknown[], X>>] : never], Return<Fns[Pos<IterationOf<K & string>>]>>;
    /**
     * @hidden
     */
    type ComposeFnAsync<Fns extends List<Function>, K extends keyof Fns> = Length<Tail<Fns>> extends Format<K & string, 'n'> ? PromiseOf<Fns[K]> : Function<[// handling unknown generics, waiting for proposal
    PromiseOf<Return<Fns[Pos<Next<IterationOf<K & string>>>]>> extends infer X ? {
        1: any;
        0: X;
    }[Or<Extends<unknown, X>, Extends<unknown[], X>>] : never], Return<Fns[Pos<IterationOf<K & string>>]>>;
    /** Compute what the input of [[Compose]] should be
     * @param Fns to compose
     * @param mode sync/async (?=`'sync'`)
     * @example
     * ```ts
     * ```
     */
    export type Composer<Fns extends List<Function>, mode extends Mode = 'sync'> = {
        'sync': {
            [K in keyof Fns]: ComposeFnSync<Fns, K>;
        };
        'async': {
            [K in keyof Fns]: ComposeFnAsync<Fns, K>;
        };
    }[mode];
    /** Compose [[Function]]s together
     * @param Fns to compose
     * @returns [[Function]]
     * @example
     * ```ts
     * import {F} from 'ts-toolbelt'
     *
     * /// If you are looking for creating types for `compose`
     * /// `Composer` will check for input & `Compose` the output
     * declare function compose<Fns extends F.Function[]>(...args: F.Composer<Fns>): F.Compose<Fns>
     *
     * const a = (a1: number) => `${a1}`
     * const c = (c1: string[]) => [c1]
     * const b = (b1: string) => [b1]
     *
     * compose(c, b, a)(42)
     *
     * /// And if you are looking for an async `pipe` type
     * declare function compose<Fns extends F.Function[]>(...args: F.Composer<Fns, 'async'>): F.Composer<Fns, 'async'>
     *
     * const a = async (a1: number) => `${a1}`
     * const b = async (b1: string) => [b1]
     * const c = async (c1: string[]) => [c1]
     *
     * await compose(c, b, a)(42)
     */
    export type Compose<Fns extends List<Function>, mode extends Mode = 'sync'> = {
        'sync': (...args: Parameters<Last<Fns>>) => Return<Head<Fns>>;
        'async': (...args: Parameters<Last<Fns>>) => Promise<PromiseOf<Return<Head<Fns>>>>;
    }[mode];
}
declare module "List/Drop" {
    import { Tail } from "List/Tail";
    import { Next } from "Iteration/Next";
    import { Cast } from "Any/Cast";
    import { IterationOf } from "Iteration/IterationOf";
    import { Iteration } from "Iteration/Iteration";
    import { Number } from "Number/Number";
    import { Key } from "Iteration/Key";
    import { Way } from "Iteration/_Internal";
    import { Reverse } from "List/Reverse";
    import { List } from "List/List";
    /**
     * @hidden
     */
    type _Drop<T extends List, N extends Number, I extends Iteration = IterationOf<'0'>> = {
        0: _Drop<Tail<T>, N, Next<I>>;
        1: T;
    }[N extends Key<I> ? 1 : 0];
    /** Remove **`N`** entries out of **`T`**
     * @param T to remove from
     * @param N to remove out
     * @param way to remove from end (?='->')
     * @returns **`any[]`**
     * @example
     * ```ts
     * ```
     */
    export type Drop<T extends List, N extends Number, way extends Way = '->'> = {
        '->': _Drop<T, N>;
        '<-': Reverse<Drop<Reverse<T>, N>>;
    }[way] extends infer X ? Cast<X, List> : never;
}
declare module "Union/NonNullable" {
    import { Exclude } from "Union/Exclude";
    /** Remove **`undefined`** & **`null`** out of **`U`**
     * @param U to make non-nullable
     * @returns [[Union]]
     * @example
     * ```ts
     * ```
     */
    export type NonNullable<U extends any> = Exclude<U, undefined | null>;
}
declare module "Object/NonNullable" {
    import { Merge } from "Object/Merge";
    import { NonNullable as UNonNullable } from "Union/NonNullable";
    import { Depth } from "Object/_Internal";
    import { Pick } from "Object/Pick";
    import { Index } from "Any/Index";
    import { Implements } from "Any/Implements";
    /**
     * @hidden
     */
    type NonNullableFlat<O> = {
        [K in keyof O]: UNonNullable<O[K]>;
    } & {};
    /**
     * @hidden
     */
    type NonNullableDeep<O> = {
        [K in keyof O]: NonNullableDeep<UNonNullable<O[K]>>;
    };
    /**
     * @hidden
     */
    type NonNullablePart<O extends object, depth extends Depth> = {
        'flat': NonNullableFlat<O>;
        'deep': NonNullableDeep<O>;
    }[depth];
    /** Make some fields of **`O`** not nullable (deeply or not)
     * (Optional fields will be left untouched & **`undefined`**)
     * @param O to make non nullable
     * @param K to choose fields (?=`keyof O`)
     * @param depth to do it deeply (?=`'flat'`)
     * @returns **`object`**
     * @example
     * ```ts
     * ```
     */
    export type NonNullable<O extends object, K extends Index = keyof O, depth extends Depth = 'flat'> = {
        1: NonNullablePart<O, depth>;
        0: Merge<NonNullablePart<Pick<O, K>, depth>, O>;
    }[Implements<keyof O, K>];
}
declare module "Union/Diff" {
    import { Exclude } from "Union/Exclude";
    /** Get an [[Union]] that is the difference between **`U1`** & **`U2`**
     * @param U1 to check differences with
     * @param U2 to check differences against
     * @returns [[Union]]
     * @example
     * ```ts
     * ```
     */
    export type Diff<U1 extends any, U2 extends any> = Exclude<U1, U2> | Exclude<U2, U1>;
}
declare module "Union/Filter" {
    import { Exclude } from "Union/Exclude";
    /** Remove **`M`** out of **`U`**
     * @param U to remove from
     * @param M to remove out
     * @returns [[Union]]
     * @example
     * ```ts
     * ```
     */
    export type Filter<U extends any, M extends any> = Exclude<U, M>;
}
declare module "Union/Intersect" {
    /** Get the intersection of **`U1`** & **`U2`**
     * @param U1 to check similarities with
     * @param U2 to check similarities against
     * @returns [[Union]]
     * @example
     * ```ts
     * ```
     */
    export type Intersect<U1 extends any, U2 extends any> = U1 & U2;
}
declare module "Union/Has" {
    import { Intersect } from "Union/Intersect";
    import { True, False } from "Boolean/Boolean";
    /** Check whether **`U`** contains **`A`**
     * (**`U`** & **`A`** can be interchanged)
     * @param U to be inspected
     * @param A to check within
     * @returns [[Boolean]]
     * @example
     * ```ts
     * ```
     */
    export type Has<U extends any, A extends any> = [Intersect<U, A>] extends [never] ? False : True;
}
declare module "Union/IntersectOf" {
    /** Transform a [[Union]] to an **intersection**
     * @param U to transform
     * @returns **intersection**
     * @example
     * ```ts
     * ```
     */
    export type IntersectOf<U extends any> = (U extends unknown ? (k: U) => void : never) extends ((k: infer I) => void) ? I : never;
}
declare module "Union/Keys" {
    /** Get the keys of a [[Union]]
     * @param U
     * @returns **`keyof`**
     * @example
     * ```ts
     * ```
     */
    export type Keys<U extends any> = U extends unknown ? keyof U : never;
}
declare module "Union/Last" {
    import { IntersectOf } from "Union/IntersectOf";
    /** Get the last item within an [[Union]]
     * (⚠️ it might not preserve order)
     * @param U
     * @returns **any**
     * @example
     * ```ts
     * ```
     */
    export type Last<U extends any> = IntersectOf<U extends unknown ? (x: U) => void : never> extends (x: infer P) => void ? P : never;
}
declare module "Object/Optional" {
    import { Merge } from "Object/Merge";
    import { Pick } from "Object/Pick";
    import { Depth } from "Object/_Internal";
    import { Index } from "Any/Index";
    import { Implements } from "Any/Implements";
    /**
     * @hidden
     */
    type OptionalFlat<O> = {
        [K in keyof O]?: O[K];
    } & {};
    /**
     * @hidden
     */
    type OptionalDeep<O> = {
        [K in keyof O]?: OptionalDeep<O[K]>;
    };
    /**
     * @hidden
     */
    type OptionalPart<O extends object, depth extends Depth> = {
        'flat': OptionalFlat<O>;
        'deep': OptionalDeep<O>;
    }[depth];
    /** Make some fields of **`O`** optional (deeply or not)
     * @param O to make optional
     * @param K to choose fields (?=`keyof O`)
     * @param depth to do it deeply (?=`'default'`)
     * @returns **`object`**
     * @example
     * ```ts
     * ```
     */
    export type Optional<O extends object, K extends Index = keyof O, depth extends Depth = 'flat'> = {
        1: OptionalPart<O, depth>;
        0: Merge<OptionalPart<Pick<O, K>, depth>, O>;
    }[Implements<keyof O, K>];
}
declare module "Object/Record" {
    import { Modx } from "Object/_Internal";
    import { Index } from "Any/Index";
    /** Create an object filled with **`A`** for the fields **`K`**
     * @param K to choose fields
     * @param A to fill fields with
     * @param modx to set modifiers (?=['!', 'W'])
     * @returns **`object`**
     * @example
     * ```ts
     * ```
     */
    export type Record<K extends Index, A extends any, modx extends Modx = ['!', 'W']> = {
        '!': {
            'R': {
                readonly [P in K]: A;
            };
            'W': {
                [P in K]: A;
            };
        };
        '?': {
            'R': {
                readonly [P in K]?: A;
            };
            'W': {
                [P in K]?: A;
            };
        };
    }[modx[0]][modx[1]];
}
declare module "Union/Strict" {
    import { Compute } from "Any/Compute";
    import { Keys } from "Union/Keys";
    import { Optional } from "Object/Optional";
    import { Record } from "Object/Record";
    /**
     * @hidden
     */
    type _Strict<U, _U = U> = U extends unknown ? U & Optional<Record<Exclude<Keys<_U>, keyof U>, never>> : never;
    /** Make a [[Union]] not allow excess properties (https://github.com/Microsoft/TypeScript/issues/20863)
     * @param U to make strict
     * @returns [[Union]]
     * @example
     * ```ts
     * ```
     */
    export type Strict<U extends object> = Compute<_Strict<U>>;
}
declare module "Union/Merge" {
    import { At } from "Object/At";
    import { Overwrite } from "Object/Overwrite";
    import { Compute } from "Any/Compute";
    import { IntersectOf } from "Union/IntersectOf";
    import { Strict } from "Union/Strict";
    /**
     * @hidden
     */
    type _Merge<U extends object> = IntersectOf<Overwrite<U, {
        [K in keyof U]-?: U extends unknown ? At<U, K> : never;
    }>>;
    /** Merge a [[Union]] of **`object`**s into a single one
     * @param U to merge
     * @returns **`object`**
     * @example
     * ```ts
     * ```
     */
    export type Merge<U extends object> = Compute<_Merge<Strict<U>>>;
}
declare module "Union/Nullable" {
    /** Add **`undefined`** to **`U`**
     * @param U to make nullable
     * @returns [[Union]]
     * @example
     * ```ts
     * ```
     */
    export type Nullable<U extends any> = U | undefined;
}
declare module "Union/Pop" {
    import { Exclude } from "Union/Exclude";
    import { Last } from "Union/Last";
    /** Remove an item out of **`U`**
     * (⚠️ it might not preserve order)
     * @param U to remove from
     * @returns [[Union]]
     * @example
     * ```ts
     * ```
     */
    export type Pop<U extends any> = Exclude<U, Last<U>>;
}
declare module "Union/Replace" {
    /** Replace **`M`** with **`A`** in **`U`**
     * @param U to update
     * @param M to select
     * @param A to update with
     * @returns [[Union]]
     * @example
     * ```ts
     * ```
     */
    export type Replace<U extends any, M extends any, A extends any> = U extends M ? A : U;
}
declare module "Union/Select" {
    /** Extract the part of **`U`** that matches **`M`**
     * @param U to extract from
     * @param M to select with
     * @returns [[Union]]
     * @example
     * ```ts
     * ```
     */
    export type Select<U extends any, M extends any> = U extends M ? U : never;
}
declare module "Union/ListOf" {
    import { Last } from "Union/Last";
    import { Prepend } from "List/Prepend";
    import { Exclude } from "Union/Exclude";
    import { List } from "List/List";
    /**
     * @hidden
     */
    type _ListOf<U, TN extends List = [], LastU = Last<U>> = {
        0: _ListOf<Exclude<U, LastU>, Prepend<TN, LastU>>;
        1: TN;
    }[[U] extends [never] ? 1 : 0];
    /** Transform a [[Union]] into a [[List]]
     * (⚠️ it might not preserve order)
     * @param U to transform
     * @returns **`any[]`**
     * @example
     * ```ts
     * ```
     */
    export type ListOf<U extends any> = _ListOf<U> extends infer X ? X : never;
}
declare module "Union/_api" {
    export { Diff } from "Union/Diff";
    export { Exclude } from "Union/Exclude";
    export { Filter } from "Union/Filter";
    export { Has } from "Union/Has";
    export { HasAll } from "Union/HasAll";
    export { Intersect } from "Union/Intersect";
    export { IntersectOf } from "Union/IntersectOf";
    export { Keys } from "Union/Keys";
    export { Last } from "Union/Last";
    export { Merge } from "Union/Merge";
    export { NonNullable } from "Union/NonNullable";
    export { Nullable } from "Union/Nullable";
    export { Pop } from "Union/Pop";
    export { Replace } from "Union/Replace";
    export { Select } from "Union/Select";
    export { Strict } from "Union/Strict";
    export { ListOf } from "Union/ListOf";
    export { ListOf as TupleOf } from "Union/ListOf";
}
declare module "List/ObjectOf" {
    import { Omit as OOmit } from "Object/Omit";
    import { HasAll } from "Union/_api";
    import { True } from "Boolean/Boolean";
    import { Cast } from "Any/Cast";
    export type _ObjectOf<T extends object> = HasAll<keyof T, keyof any[]> extends True ? number extends (Cast<T, any[]>)['length'] ? OOmit<T, Exclude<keyof any[], number>> : OOmit<T, keyof any[]> : T;
    /** Transform a [[List]] or an `Array` into an **`object`**
     * @param T to transform
     * @returns **`object`**
     * @example
     * ```ts
     * ```
     */
    export type ObjectOf<T extends object> = T extends unknown ? _ObjectOf<T> : never;
}
declare module "List/Keys" {
    import { Index } from "Any/Index";
    import { Exclude } from "Union/Exclude";
    import { List } from "List/List";
    /** Get the keys of a [[List]]
     * @param T
     * @returns **`keyof`**
     * @example
     * ```ts
     * ```
     */
    export type Keys<T extends List> = (Exclude<keyof T, keyof any[]> & Index) | number;
}
declare module "List/NonNullable" {
    import { Depth } from "Object/_Internal";
    import { NonNullable as ONonNullable } from "Object/NonNullable";
    import { ListOf } from "Object/ListOf";
    import { Cast } from "Any/Cast";
    import { Index } from "Any/Index";
    import { ObjectOf } from "List/ObjectOf";
    import { Implements } from "Any/Implements";
    import { List } from "List/List";
    /** Make some entries of **`T`** not nullable (deeply or not)
     * @param T to make non nullable
     * @param K to choose fields (?=`keyof O`)
     * @param depth to do it deeply (?=`'flat'`)
     * @returns **`any[]`**
     * @example
     * ```ts
     * ```
     */
    export type NonNullable<T extends List, K extends Index = keyof T, depth extends Depth = 'flat'> = {
        1: Cast<ONonNullable<T, keyof T, depth>, List>;
        0: ListOf<ONonNullable<ObjectOf<T>, K, depth>>;
    }[Implements<keyof T, K>];
}
declare module "Function/Curry" {
    import { Pos } from "Iteration/Pos";
    import { Append } from "List/Append";
    import { Concat } from "List/Concat";
    import { Drop } from "List/Drop";
    import { Length } from "List/Length";
    import { Next } from "Iteration/Next";
    import { Cast } from "Any/Cast";
    import { Parameters } from "Function/Parameters";
    import { Return } from "Function/Return";
    import { IterationOf } from "Iteration/IterationOf";
    import { Iteration } from "Iteration/Iteration";
    import { Key } from "Iteration/Key";
    import { NonNullable } from "List/NonNullable";
    import { x } from "Any/x";
    import { List } from "List/List";
    /**
     * @hidden
     */
    type GapOf<T1 extends List, T2 extends List, TN extends List, I extends Iteration = IterationOf<'0'>> = T1[Pos<I>] extends x ? Append<TN, T2[Pos<I>]> : TN;
    /**
     * @hidden
     */
    type _GapsOf<T1 extends List, T2 extends List, TN extends List = [], I extends Iteration = IterationOf<'0'>> = {
        0: _GapsOf<T1, T2, GapOf<T1, T2, TN, I>, Next<I>>;
        1: Concat<TN, Drop<T2, Key<I>>>;
    }[Pos<I> extends Length<T1> ? 1 : 0];
    /**
     * @hidden
     */
    type GapsOf<T1 extends List, T2 extends List> = _GapsOf<T1, T2> extends infer X ? Cast<X, List> : never;
    /**
     * @hidden
     */
    type Gaps<T extends List> = NonNullable<{
        [K in keyof T]?: T[K] | x;
    }>;
    /** Curry a [[Function]]
     * @param F to curry
     * @returns [[Function]]
     * @example
     * ```ts
     * import {F} from 'ts-toolbelt'
     *
     * /// If you are looking for creating types for `curry`
     * /// It handles placeholders and variable arguments
     * declare function curry<Fn extends F.Function>(fn: Fn): F.Curry<Fn>
     * ```
     */
    export type Curry<F extends (...args: any[]) => any> = <T extends List>(...args: Cast<T, Gaps<Parameters<F>>>) => GapsOf<T, Parameters<F>> extends infer G ? Length<Cast<G, List>> extends infer L ? L extends 0 ? Return<F> : L extends 1 ? (...args: Cast<G, List>) => Return<F> : Curry<(...args: Cast<G, List>) => Return<F>> : never : never;
}
declare module "Function/Length" {
    import { Function } from "Function/Function";
    import { Parameters } from "Function/Parameters";
    import { Formats } from "Iteration/_Internal";
    import { Length as TLength } from "List/Length";
    /** Extract arguments' length from a [[Function]]
     * @param F to extract from
     * @param fmt output (?=`'n'`)
     * @returns **`string`** or **`number`**
     * @example
     * ```ts
     * import {F} from 'ts-toolbelt'
     *
     * const fn = (a1: any, a2: any) => {}
     *
     * type test0 = F.LengthOf<typeof fn>               // 2
     *
     * type test1 = F.LengthOf<(a1?: any) => any>       // 0 | 1
     *
     * type test2 = F.LengthOf<(...a: any[]) => any>    // number
     * ```
     */
    export type Length<Fn extends Function, fmt extends Formats = 'n'> = TLength<Parameters<Fn>, fmt>;
}
declare module "Function/NoInfer" {
    /** Explain to TS which function parameter has priority for generic inference
     * @param A to de-prioritize
     * @returns **`A`**
     * @example
     * ```ts
     * import {F} from 'ts-toolbelt'
     *
     * const fn0 = <A extends any>(a0: A, a1: F.NoInfer<A>): A => {
     *     return {} as unknown as A // just for the example
     * }
     *
     * const fn1 = <A extends any>(a0: F.NoInfer<A>, a1: A): A => {
     *     return {} as unknown as A // just for the example
     * }
     *
     * const fn2 = <A extends any>(a0: F.NoInfer<A>, a1: F.NoInfer<A>): A => {
     *     return {} as unknown as A // just for the example
     * }
     *
     * const test0 = fn0('b', 'a') // error: infer priority is `a0`
     * const test1 = fn1('b', 'a') // error: infer priority is `a1`
     * const test2 = fn2('b', 'a') // works: infer priority is `a0` | `a1`
     * ```
     * @see https://stackoverflow.com/questions/56687668
     */
    export type NoInfer<A extends any> = [A][A extends any ? 0 : never];
}
declare module "Iteration/Prev" {
    import { IterationMap } from "Iteration/IterationOf";
    import { Iteration } from "Iteration/Iteration";
    /** Move **`I`**'s position backwards
     * @param I to move
     * @returns [[Iteration]]
     * @example
     * ```ts
     * import {I} from 'ts-toolbelt'
     *
     * type i = I.IterationOf<'20'>
     *
     * type test0 = I.Pos<i>         // 20
     * type test1 = I.Pos<I.Prev<i>> // 19
     * ```
     */
    export type Prev<I extends Iteration> = IterationMap[I[0]];
}
declare module "Function/Pipe" {
    import { Function } from "Function/Function";
    import { Pos } from "Iteration/Pos";
    import { Prev } from "Iteration/Prev";
    import { IterationOf } from "Iteration/IterationOf";
    import { Head } from "List/Head";
    import { Last } from "List/Last";
    import { Return } from "Function/Return";
    import { Parameters } from "Function/Parameters";
    import { Mode } from "Function/_Internal";
    import { PromiseOf } from "Class/PromiseOf";
    import { Or } from "Boolean/Or";
    import { Extends } from "Any/Extends";
    import { List } from "List/List";
    /**
     * @hidden
     */
    type PipeFnSync<Fns extends List<Function>, K extends keyof Fns> = K extends '0' ? Fns[K] : Function<[// handling unknown generics, waiting for proposal
    Return<Fns[Pos<Prev<IterationOf<K & string>>>]> extends infer X ? {
        1: any;
        0: X;
    }[Or<Extends<unknown, X>, Extends<unknown[], X>>] : never], Return<Fns[Pos<IterationOf<K & string>>]>>;
    /**
     * @hidden
     */
    type PipeFnAsync<Fns extends List<Function>, K extends keyof Fns> = K extends '0' ? PromiseOf<Fns[K]> : Function<[// handling unknown generics, waiting for proposal
    PromiseOf<Return<Fns[Pos<Prev<IterationOf<K & string>>>]>> extends infer X ? {
        1: any;
        0: X;
    }[Or<Extends<unknown, X>, Extends<unknown[], X>>] : never], Return<Fns[Pos<IterationOf<K & string>>]>>;
    /** Compute what the input of [[Pipe]] should be
     * @param Fns to pipe
     * @param mode sync/async (?=`'sync'`)
     * @example
     * ```ts
     * ```
     */
    export type Piper<Fns extends List<Function>, mode extends Mode = 'sync'> = {
        'sync': {
            [K in keyof Fns]: PipeFnSync<Fns, K>;
        };
        'async': {
            [K in keyof Fns]: PipeFnAsync<Fns, K>;
        };
    }[mode];
    /** Pipe [[Function]]s together
     * @param Fns to pipe
     * @param mode sync/async (?=`'sync'`)
     * @returns [[Function]]
     * @example
     * ```ts
     * import {F} from 'ts-toolbelt'
     *
     * /// If you are looking for creating types for `pipe`
     * /// `Piper` will check for input & `Piped` the output
     * declare function pipe<Fns extends F.Function[]>(...args: F.Piper<Fns>): F.Pipe<Fns>
     *
     * const a = (a1: number) => `${a1}`
     * const b = (b1: string) => [b1]
     * const c = (c1: string[]) => [c1]
     *
     * pipe(a, b, c)(42)
     *
     * /// And if you are looking for an async `pipe` type
     * declare function pipe<Fns extends F.Function[]>(...args: F.Piper<Fns, 'async'>): F.Pipe<Fns, 'async'>
     *
     * const a = async (a1: number) => `${a1}`
     * const b = async (b1: string) => [b1]
     * const c = async (c1: string[]) => [c1]
     *
     * await pipe(a, b, c)(42)
     * ```
     */
    export type Pipe<Fns extends List<Function>, mode extends Mode = 'sync'> = {
        'sync': (...args: Parameters<Head<Fns>>) => Return<Last<Fns>>;
        'async': (...args: Parameters<Head<Fns>>) => Promise<PromiseOf<Return<Last<Fns>>>>;
    }[mode];
}
declare module "Function/Promisify" {
    import { Function } from "Function/Function";
    import { Parameters } from "Function/Parameters";
    import { Return } from "Function/Return";
    /** Creates a promisified version of a **`Function`** **`F`**
     * @param F to promisify
     * @returns async F
     * @example
     * ```ts
     * import {F} from 'ts-toolbelt'
     *
     * type test0 = F.Promisify<(a: number) => number> // (a: number) => Promise<number>
     * ```
     */
    export type Promisify<F extends Function> = Return<F> extends Promise<any> ? F : (...args: Parameters<F>) => Promise<Return<F>>;
}
declare module "Function/_api" {
    export { Composer, Compose } from "Function/Compose";
    export { Curry } from "Function/Curry";
    export { Function } from "Function/Function";
    export { Length } from "Function/Length";
    export { NoInfer } from "Function/NoInfer";
    export { Parameters } from "Function/Parameters";
    export { Piper, Pipe } from "Function/Pipe";
    export { Promisify } from "Function/Promisify";
    export { Return } from "Function/Return";
}
declare module "Iteration/_api" {
    export { Format } from "Iteration/Format";
    export { Iteration } from "Iteration/Iteration";
    export { IterationOf } from "Iteration/IterationOf";
    export { Key } from "Iteration/Key";
    export { Next } from "Iteration/Next";
    export { Pos } from "Iteration/Pos";
    export { Prev } from "Iteration/Prev";
}
declare module "Misc/JSON/Primitive" {
    /** Basic JSON Value
     */
    export type Primitive = string | number | boolean | null;
}
declare module "Misc/JSON/Object" {
    import { Value } from "Misc/JSON/Value";
    /** An object of JSON [[Value]]s
     */
    export interface Object {
        [k: string]: Value;
    }
}
declare module "Misc/JSON/Value" {
    import { Primitive } from "Misc/JSON/Primitive";
    import { List } from "Misc/JSON/Array";
    import { Object } from "Misc/JSON/Object";
    /** Any JSON data/value
     */
    export type Value = Primitive | Object | List;
}
declare module "Misc/JSON/Array" {
    import { Value } from "Misc/JSON/Value";
    /** A list of JSON [[Value]]s
     */
    export interface List extends Array<Value> {
    }
}
declare module "Misc/JSON/_api" {
    export { List as Array } from "Misc/JSON/Array";
    export { Object } from "Misc/JSON/Object";
    export { Primitive } from "Misc/JSON/Primitive";
    export { Value } from "Misc/JSON/Value";
}
declare module "Misc/Promisable" {
    /** A way to say that you can handle **`Promises`** and non-**`Promises`**. This
     * is often the case if you're a heavy user of `await` and `async`.
     * @param A **`A`** A type
     * @returns **`A | Promise<A>`**
     * @example
     */
    export type Promisable<A extends any> = A | Promise<A>;
}
declare module "Misc/_api" {
    import * as JSON from "Misc/JSON/_api";
    export { JSON };
    export { Promisable } from "Misc/Promisable";
}
declare module "Number/IsNegative" {
    import { IterationOf } from "Iteration/IterationOf";
    import { Iteration } from "Iteration/Iteration";
    import { Number } from "Number/Number";
    import { True, False } from "Boolean/Boolean";
    /**
     * @hidden
     */
    export type _IsNegative<N extends Iteration> = {
        '-': True;
        '+': False;
        '0': False;
    }[N[4]];
    /** Check whether a [[Number]] is negative or not
     * @param N to check
     * @returns [[Boolean]]
     * @example
     * ```ts
     * import {N} from 'ts-toolbelt'
     *
     * type test0 = N.IsNegative<'0'>  // False
     * type test1 = N.IsNegative<'-7'> // True
     * type test2 = N.IsNegative<'7'>  // False
     * ```
     */
    export type IsNegative<N extends Number> = _IsNegative<IterationOf<N>>;
}
declare module "Number/Minus" {
    import { IterationOf } from "Iteration/IterationOf";
    import { Iteration } from "Iteration/Iteration";
    import { Pos } from "Iteration/Pos";
    import { Prev } from "Iteration/Prev";
    import { Next } from "Iteration/Next";
    import { _IsNegative } from "Number/IsNegative";
    import { Cast } from "Any/Cast";
    import { Number } from "Number/Number";
    import { Formats } from "Iteration/_Internal";
    import { Format } from "Iteration/Format";
    /**
     * @hidden
     */
    type _MinusPositive<N1 extends Iteration, N2 extends Iteration> = {
        0: _MinusPositive<Prev<N1>, Prev<N2>>;
        1: N1;
        2: N2;
    }[Pos<N2> extends 0 ? 1 : number extends Pos<N2> ? 2 : 0];
    /**
     * @hidden
     */
    type MinusPositive<N1 extends Iteration, N2 extends Iteration> = _MinusPositive<N1, N2> extends infer X ? Cast<X, Iteration> : never;
    /**
     * @hidden
     */
    type _MinusNegative<N1 extends Iteration, N2 extends Iteration> = {
        0: _MinusNegative<Next<N1>, Next<N2>>;
        1: N1;
        2: N2;
    }[Pos<N2> extends 0 ? 1 : number extends Pos<N2> ? 2 : 0];
    /**
     * @hidden
     */
    type MinusNegative<N1 extends Iteration, N2 extends Iteration> = _MinusNegative<N1, N2> extends infer X ? Cast<X, Iteration> : never;
    /**
     * @hidden
     */
    export type _Minus<N1 extends Iteration, N2 extends Iteration> = {
        0: MinusPositive<N1, N2>;
        1: MinusNegative<N1, N2>;
    }[_IsNegative<N2>];
    /** Subtract a [[Number]] from another one
     * @param N1 Left-hand side
     * @param N2 Right-hand side
     * @param fmt output (?=`'s'`)
     * @returns **`string | number | boolean`**
     * @example
     * ```ts
     * import {N} from 'ts-toolbelt'
     *
     * type test0 = N.Minus<'2', '10'>        // '-8'
     * type test1 = N.Minus<'0', '40'>        // '-40'
     * type test2 = N.Minus<'0', '40', 's'>   // '-40'
     * type test3 = N.Minus<'0', '40', 'n'>   //  -40
     * type test4 = N.Minus<'-20', '40', 's'> // string
     * type test5 = N.Minus<'-20', '40', 'n'> // number
     * ```
     */
    export type Minus<N1 extends Number, N2 extends Number, fmt extends Formats = 's'> = Format<_Minus<IterationOf<N1>, IterationOf<N2>>, fmt>;
}
declare module "Number/Negate" {
    import { _Minus } from "Number/Minus";
    import { IterationOf } from "Iteration/IterationOf";
    import { Iteration } from "Iteration/Iteration";
    import { Number } from "Number/Number";
    import { Formats } from "Iteration/_Internal";
    import { Format } from "Iteration/Format";
    /**
     * @hidden
     */
    export type _Negate<N extends Iteration> = _Minus<IterationOf<'0'>, N>;
    /** Negate a [[Number]]
     * @param N to negate
     * @param fmt output (?=`'s'`)
     * @returns **`string | number | boolean`**
     * @example
     * ```ts
     * import {N} from 'ts-toolbelt'
     *
     * type test0 = N.Negate<'-10'>     //  '10'
     * type test1 = N.Negate<'10'>      // '-10'
     * type test2 = N.Negate<'10', 's'> // '-10'
     * type test3 = N.Negate<'10', 'n'> //  -10
     * type test4 = N.Negate<'-100'>    // string
     * ```
     */
    export type Negate<N extends Number, fmt extends Formats = 's'> = Format<_Negate<IterationOf<N>>, fmt>;
}
declare module "Number/Absolute" {
    import { _Negate } from "Number/Negate";
    import { _IsNegative } from "Number/IsNegative";
    import { IterationOf } from "Iteration/IterationOf";
    import { Iteration } from "Iteration/Iteration";
    import { Number } from "Number/Number";
    import { Formats } from "Iteration/_Internal";
    import { Format } from "Iteration/Format";
    /**
     * @hidden
     */
    export type _Absolute<N extends Iteration> = {
        0: N;
        1: _Negate<N>;
    }[_IsNegative<N>];
    /** Get the absolute value of a [[Number]]
     * @param N to absolute
     * @param fmt output (?=`'s'`)
     * @returns **`string | number | boolean`**
     * @example
     * ```ts
     * import {N} from 'ts-toolbelt'
     *
     * type test0 = N.Absolute<'-20'>      // '20'
     *
     * type test1 = N.Absolute<'-20', 's'> // '20'
     * type test2 = N.Absolute<'-20', 'n'> //  20
     * ```
     */
    export type Absolute<N extends Number, fmt extends Formats = 's'> = Format<_Absolute<IterationOf<N>>, fmt>;
}
declare module "Number/IsZero" {
    import { IterationOf } from "Iteration/IterationOf";
    import { Iteration } from "Iteration/Iteration";
    import { Number } from "Number/Number";
    import { True, False } from "Boolean/Boolean";
    /**
     * @hidden
     */
    export type _IsZero<N extends Iteration> = {
        '-': False;
        '+': False;
        '0': True;
    }[N[4]];
    /** Check whether a [[Number]] is null or not
     * @param N to check
     * @returns [[Boolean]]
     * @example
     * ```ts
     * import {N} from 'ts-toolbelt'
     *
     * type test0 = N.IsZero<'0'>  // True
     * type test1 = N.IsZero<'-7'> // False
     * type test2 = N.IsZero<'7'>  // False
     * ```
     */
    export type IsZero<N extends Number> = _IsZero<IterationOf<N>>;
}
declare module "Number/Format" {
    import { Formats } from "Number/_Internal";
    import { Number } from "Number/Number";
    import { IsZero } from "Number/IsZero";
    import { Not } from "Boolean/Not";
    import { Pos } from "Iteration/Pos";
    import { IterationOf } from "Iteration/IterationOf";
    /** Change the format of a [[Number]]
     * @param B to transform
     * @returns **`string | number | boolean`**
     * @example
     * ```ts
     * import {N} from 'ts-toolbelt'
     *
     * type test0 = N.Format<'30', 'b'> // True
     * type test1 = N.Format<'30', 'n'> // 30
     * ```
     */
    export type Format<N extends Number, fmt extends Formats> = {
        'b': Not<IsZero<N>>;
        'n': Pos<IterationOf<N>>;
        's': N;
    }[fmt];
}
declare module "Number/IsPositive" {
    import { IterationOf } from "Iteration/IterationOf";
    import { Iteration } from "Iteration/Iteration";
    import { Number } from "Number/Number";
    import { True, False } from "Boolean/Boolean";
    /**
     * @hidden
     */
    export type _IsPositive<N extends Iteration> = {
        '-': False;
        '+': True;
        '0': False;
    }[N[4]];
    /** Check whether a [[Number]] is positive or not
     * @param N to check
     * @returns [[Boolean]]
     * @example
     * ```ts
     * import {N} from 'ts-toolbelt'
     *
     * type test0 = N.IsPositive<'0'>  // False
     * type test1 = N.IsPositive<'-7'> // False
     * type test2 = N.IsPositive<'7'>  // True
     * ```
     */
    export type IsPositive<N extends Number> = _IsPositive<IterationOf<N>>;
}
declare module "Number/Greater" {
    import { _Minus } from "Number/Minus";
    import { _IsPositive } from "Number/IsPositive";
    import { IterationOf } from "Iteration/IterationOf";
    import { Iteration } from "Iteration/Iteration";
    import { Number } from "Number/Number";
    /**
     * @hidden
     */
    export type _Greater<N1 extends Iteration, N2 extends Iteration> = _IsPositive<_Minus<N1, N2>>;
    /** Check if a [[Number]] is bigger than another one
     * @param N1 to compare
     * @param N2 to compare to
     * @returns [[Boolean]]
     * @example
     * ```ts
     * import {N} from 'ts-toolbelt'
     *
     * type test0 = N.Greater<'7', '5'> // True
     * type test1 = N.Greater<'5', '5'> // False
     * type test2 = N.Greater<'5', '7'> // False
     * ```
     */
    export type Greater<N1 extends Number, N2 extends Number> = _Greater<IterationOf<N1>, IterationOf<N2>>;
}
declare module "Number/GreaterEq" {
    import { Equals } from "Any/Equals";
    import { _Greater } from "Number/Greater";
    import { IterationOf } from "Iteration/IterationOf";
    import { Iteration } from "Iteration/Iteration";
    import { Number } from "Number/Number";
    import { Or } from "Boolean/Or";
    /**
     * @hidden
     */
    export type _GreaterEq<N1 extends Iteration, N2 extends Iteration> = Or<Equals<N1, N2>, _Greater<N1, N2>>;
    /** Check if a [[Number]] is greater or equal to another one
     * @param N1 to compare
     * @param N2 to compare to
     * @returns [[Boolean]]
     * @example
     * ```ts
     * import {N} from 'ts-toolbelt'
     *
     * type test0 = N.GreaterEq<'7', '5'> // True
     * type test1 = N.GreaterEq<'5', '5'> // True
     * type test2 = N.GreaterEq<'5', '7'> // False
     * ```
     */
    export type GreaterEq<N1 extends Number, N2 extends Number> = _GreaterEq<IterationOf<N1>, IterationOf<N2>>;
}
declare module "Number/Lower" {
    import { _Greater } from "Number/Greater";
    import { IterationOf } from "Iteration/IterationOf";
    import { Iteration } from "Iteration/Iteration";
    import { Number } from "Number/Number";
    /**
     * @hidden
     */
    export type _Lower<N1 extends Iteration, N2 extends Iteration> = _Greater<N2, N1>;
    /** Check if a [[Number]] is lower than another one
     * @param N1 to compare
     * @param N2 to compare to
     * @returns [[Boolean]]
     * @example
     * ```ts
     * import {N} from 'ts-toolbelt'
     *
     * type test0 = N.Lower<'7', '5'> // False
     * type test1 = N.Lower<'5', '5'> // False
     * type test2 = N.Lower<'5', '7'> // True
     * ```
     */
    export type Lower<N1 extends Number, N2 extends Number> = _Lower<IterationOf<N1>, IterationOf<N2>>;
}
declare module "Number/LowerEq" {
    import { GreaterEq } from "Number/GreaterEq";
    import { Number } from "Number/Number";
    /** Check if a [[Number]] is lower or equal to another one
     * @param N1 to compare
     * @param N2 to compare to
     * @returns [[Boolean]]
     * @example
     * ```ts
     * import {N} from 'ts-toolbelt'
     *
     * type test0 = N.LowerEq<'7', '5'> // False
     * type test1 = N.LowerEq<'5', '5'> // True
     * type test2 = N.LowerEq<'5', '7'> // True
     * ```
     */
    export type LowerEq<N1 extends Number, N2 extends Number> = GreaterEq<N2, N1>;
}
declare module "Number/Max" {
    import { Prev } from "Iteration/Prev";
    import { IterationOf } from "Iteration/IterationOf";
    import { Iteration } from "Iteration/Iteration";
    import { Next } from "Iteration/Next";
    import { Numbers } from "Number/_Internal";
    import { Number } from "Number/Number";
    import { Formats } from "Iteration/_Internal";
    import { Key } from "Iteration/Key";
    import { _IsNegative } from "Number/IsNegative";
    import { Exclude } from "Union/Exclude";
    import { Cast } from "Any/Cast";
    import { Format } from "Iteration/Format";
    import { Extends } from "Any/Extends";
    import { Or } from "Boolean/Or";
    import { True } from "Boolean/Boolean";
    /**
     * @hidden
     */
    type _MaxPositive<N extends Number, I extends Iteration = IterationOf<'0'>> = {
        0: _MaxPositive<Exclude<N, Key<I>>, Next<I>>;
        1: Prev<I>;
        2: string;
    }[[N] extends [never] ? 1 : string extends N ? 2 : 0];
    /**
     * @hidden
     */
    type MaxPositive<N extends Number> = _MaxPositive<N> extends infer X ? Cast<X, Iteration> : never;
    /**
     * @hidden
     */
    type _MaxNegative<N extends Number, I extends Iteration = IterationOf<'0'>> = {
        0: _MaxNegative<Exclude<N, Key<I>>, Prev<I>>;
        1: I;
    }[Or<Extends<Key<I>, N>, Extends<string, Key<I>>>];
    /**
     * @hidden
     */
    type MaxNegative<N extends Number> = _MaxNegative<N> extends infer X ? Cast<X, Iteration> : never;
    /**
     * @hidden
     */
    export type _Max<N extends Iteration> = _IsNegative<N> extends True ? MaxNegative<Key<N>> : MaxPositive<Exclude<Key<N>, Numbers['string']['-']>>;
    /** Get the biggest [[Number]] within an [[Union]]
     * @param N [[Union]]
     * @param fmt output (?=`'s'`)
     * @returns **`string | number | boolean`**
     * @example
     * ```ts
     * import {N} from 'ts-toolbelt'
     *
     * type test0 = N.Max<'-2' | '10' | '3'>      // '10'
     * type test1 = N.Max<'-2' | '10' | '3', 's'> // '10'
     * type test2 = N.Max<'-2' | '10' | '3', 'n'> //  10
     * type test3 = N.Min<'-2' | '10' | 'oops'>   // string
     * ```
     */
    export type Max<N extends Number, fmt extends Formats = 's'> = Format<_Max<IterationOf<N>>, fmt>;
}
declare module "Number/Min" {
    import { IterationOf } from "Iteration/IterationOf";
    import { Iteration } from "Iteration/Iteration";
    import { Next } from "Iteration/Next";
    import { Numbers } from "Number/_Internal";
    import { Number } from "Number/Number";
    import { Formats } from "Iteration/_Internal";
    import { Cast } from "Any/Cast";
    import { Key } from "Iteration/Key";
    import { Prev } from "Iteration/Prev";
    import { _IsPositive } from "Number/IsPositive";
    import { Exclude } from "Union/Exclude";
    import { Format } from "Iteration/Format";
    import { True } from "Boolean/Boolean";
    import { Or } from "Boolean/Or";
    import { Extends } from "Any/Extends";
    /**
     * @hidden
     */
    type _MinPositive<N extends Number, I extends Iteration = IterationOf<'0'>> = {
        0: _MinPositive<N, Next<I>>;
        1: I;
    }[Or<Extends<Key<I>, N>, Extends<string, Key<I>>>];
    /**
     * @hidden
     */
    type MinPositive<N extends Number> = _MinPositive<N> extends infer X ? Cast<X, Iteration> : never;
    /**
     * @hidden
     */
    type _MinNegative<N extends Number, I extends Iteration = IterationOf<'0'>> = {
        0: _MinNegative<Exclude<N, Key<I>>, Prev<I>>;
        1: Next<I>;
        2: string;
    }[[N] extends [never] ? 1 : string extends N ? 2 : 0];
    /**
     * @hidden
     */
    type MinNegative<N extends Number> = _MinNegative<N> extends infer X ? Cast<X, Iteration> : never;
    /**
     * @hidden
     */
    export type _Min<N extends Iteration> = _IsPositive<N> extends True ? MinPositive<Key<N>> : MinNegative<Exclude<Key<N>, Numbers['string']['+']>>;
    /** Get the smallest [[Number]] within an [[Union]]
     * @param N [[Union]]
     * @param fmt output (?=`'s'`)
     * @returns **`string | number | boolean`**
     * @example
     * ```ts
     * import {N} from 'ts-toolbelt'
     *
     * type test0 = N.Min<'-2' | '10' | '3'>      // '-2'
     * type test1 = N.Min<'-2' | '10' | '3', 's'> // '-2'
     * type test2 = N.Min<'-2' | '10' | '3', 'n'> //  -2
     * type test3 = N.Min<'-2' | '10' | 'oops'>   // string
     * ```
     */
    export type Min<N extends Number, fmt extends Formats = 's'> = Format<_Min<IterationOf<N>>, fmt>;
}
declare module "Number/Plus" {
    import { IterationOf } from "Iteration/IterationOf";
    import { Iteration } from "Iteration/Iteration";
    import { Pos } from "Iteration/Pos";
    import { Prev } from "Iteration/Prev";
    import { Next } from "Iteration/Next";
    import { _IsNegative } from "Number/IsNegative";
    import { Cast } from "Any/Cast";
    import { Number } from "Number/Number";
    import { Formats } from "Iteration/_Internal";
    import { Format } from "Iteration/Format";
    /**
     * @hidden
     */
    type _PlusPositive<N1 extends Iteration, N2 extends Iteration> = {
        0: _PlusPositive<Next<N1>, Prev<N2>>;
        1: N1;
        2: number;
    }[Pos<N2> extends 0 ? 1 : number extends Pos<N2> ? 2 : 0];
    /**
     * @hidden
     */
    type PlusPositive<N1 extends Iteration, N2 extends Iteration> = _PlusPositive<N1, N2> extends infer X ? Cast<X, Iteration> : never;
    /**
     * @hidden
     */
    type _PlusNegative<N1 extends Iteration, N2 extends Iteration> = {
        0: _PlusNegative<Prev<N1>, Next<N2>>;
        1: N1;
        2: number;
    }[Pos<N2> extends 0 ? 1 : number extends Pos<N2> ? 2 : 0];
    /**
     * @hidden
     */
    type PlusNegative<N1 extends Iteration, N2 extends Iteration> = _PlusNegative<N1, N2> extends infer X ? Cast<X, Iteration> : never;
    /**
     * @hidden
     */
    export type _Plus<N1 extends Iteration, N2 extends Iteration> = {
        0: PlusPositive<N1, N2>;
        1: PlusNegative<N1, N2>;
    }[_IsNegative<N2>];
    /** Add a [[Number]] to another one
     * @param N1 Left-hand side
     * @param N2 Right-hand side
     * @param fmt output (?=`'s'`)
     * @returns **`string | number | boolean`**
     * @example
     * ```ts
     * import {N} from 'ts-toolbelt'
     *
     * type test0 = N.Plus<'2', '10'>        // '12'
     * type test1 = N.Plus<'0', '40'>        // '40'
     * type test2 = N.Plus<'0', '40', 's'>   // '40'
     * type test3 = N.Plus<'0', '40', 'n'>   //  40
     * type test4 = N.Plus<'-20', '40', 's'> // '20'
     * type test5 = N.Plus<'-20', '40', 'n'> //  20
     * ```
     */
    export type Plus<N1 extends Number, N2 extends Number, fmt extends Formats = 's'> = Format<_Plus<IterationOf<N1>, IterationOf<N2>>, fmt>;
}
declare module "Number/Range" {
    import { IterationOf } from "Iteration/IterationOf";
    import { Iteration } from "Iteration/Iteration";
    import { Prepend } from "List/Prepend";
    import { Prev } from "Iteration/Prev";
    import { Next } from "Iteration/Next";
    import { Number } from "Number/Number";
    import { Cast } from "Any/Cast";
    import { Formats } from "Iteration/_Internal";
    import { Way } from "Iteration/_Internal";
    import { Format } from "Iteration/Format";
    import { List } from "List/List";
    /**
     * @hidden
     */
    type RangeForth<From extends Iteration, To extends Iteration, fmt extends Formats = 's', T extends List = []> = {
        0: RangeForth<Prev<From>, To, fmt, Prepend<T, Format<From, fmt>>>;
        1: T;
    }[From extends To ? 1 : 0];
    /**
     * @hidden
     */
    type RangeBack<From extends Iteration, To extends Iteration, fmt extends Formats = 's', T extends List = []> = {
        0: RangeBack<Next<From>, To, fmt, Prepend<T, Format<From, fmt>>>;
        1: T;
    }[From extends To ? 1 : 0];
    /**
     * @hidden
     */
    type _Range<From extends Iteration, To extends Iteration, way extends Way, fmt extends Formats> = {
        '->': RangeForth<To, Prev<From>, fmt>;
        '<-': RangeBack<From, Next<To>, fmt>;
    }[way];
    /** Create a range of **number**s
     * @param From to start with
     * @param To to end with
     * @param way to reverse it (?=`'->'`)
     * @param fmt output (?=`'s'`)
     * @returns **`string[] | number[] | boolean[]`**
     * @example
     * ```ts
     * import {N} from 'ts-toolbelt'
     *
     * type test0 = N.Range<'-2', '1'>            // ['-2', '-1', '0', '1']
     * type test1 = N.Range<'-2', '1', '->'>      // ['-2', '-1', '0', '1']
     * type test2 = N.Range<'-2', '1', '<-'>      // ['1', '0', '-1', '-2']
     * type test3 = N.Range<'-2', '1', '<-', 's'> // ['1', '0', '-1', '-2']
     * type test4 = N.Range<'-2', '1', '->', 'n'> // [-2 , -1 ,   0 ,   1 ]
     * ```
     */
    export type Range<From extends Number, To extends Number, way extends Way = '->', fmt extends Formats = 's'> = _Range<IterationOf<From>, IterationOf<To>, way, fmt> extends infer X ? Cast<X, {
        s: string[];
        n: number[];
    }[fmt]> : never;
}
declare module "Number/_api" {
    export { Absolute } from "Number/Absolute";
    export { Format } from "Number/Format";
    export { Greater } from "Number/Greater";
    export { GreaterEq } from "Number/GreaterEq";
    export { IsNegative } from "Number/IsNegative";
    export { IsPositive } from "Number/IsPositive";
    export { IsZero } from "Number/IsZero";
    export { Lower } from "Number/Lower";
    export { LowerEq } from "Number/LowerEq";
    export { Max } from "Number/Max";
    export { Min } from "Number/Min";
    export { Minus } from "Number/Minus";
    export { Negate } from "Number/Negate";
    export { NumberOf } from "Number/NumberOf";
    export { Plus } from "Number/Plus";
    export { Range } from "Number/Range";
}
declare module "Object/P/_Internal" {
    import { Index } from "Any/Index";
    /**
     * @hidden
     */
    export type Path = [Index, ...Index[]];
}
declare module "Object/P/Merge" {
    import { IterationOf } from "Iteration/IterationOf";
    import { Iteration } from "Iteration/Iteration";
    import { Pos } from "Iteration/Pos";
    import { Next } from "Iteration/Next";
    import { Path as PPath } from "Object/P/_Internal";
    import { Index } from "Any/Index";
    import { Merge as OMerge } from "Object/Merge";
    import { Length } from "List/Length";
    import { List } from "List/List";
    import { Depth } from "Object/_Internal";
    /**
     * @hidden
     */
    type _Merge<O, Path extends List<Index>, O1 extends object, depth extends Depth, I extends Iteration = IterationOf<'0'>> = O extends object ? Pos<I> extends Length<Path> ? OMerge<O, O1, depth> : {
        [K in keyof O]: K extends Path[Pos<I>] ? _Merge<O[K], Path, O1, depth, Next<I>> : O[K];
    } & {} : O;
    /** Complete the fields of **`O`** at **`Path`** with the ones of **`O1`**
     * (⚠️ this type is expensive)
     * @param O to complete
     * @param Path to be followed
     * @param O1 to copy from
     * @param depth to do it deeply (?=`'flat'`)
     * @returns **`object`**
     * @example
     * ```ts
     * ```
     */
    export type Merge<O extends object, Path extends PPath, O1 extends object, depth extends Depth = 'flat'> = _Merge<O, Path, O1, depth>;
}
declare module "List/LastIndex" {
    import { Length } from "List/Length";
    import { Formats } from "Iteration/_Internal";
    import { Tail } from "List/Tail";
    import { List } from "List/List";
    /** Get the last index of **`T`**
     * @param T to get from
     * @param fmt output (?=`'n'`)
     * @returns **`string`** or **`number`**
     * @example
     * ```ts
     * ```
     */
    export type LastIndex<T extends List, fmt extends Formats = 'n'> = Length<Tail<T>, fmt>;
}
declare module "Object/P/Omit" {
    import { IterationOf } from "Iteration/IterationOf";
    import { Iteration } from "Iteration/Iteration";
    import { Pos } from "Iteration/Pos";
    import { Next } from "Iteration/Next";
    import { Path as PPath } from "Object/P/_Internal";
    import { Index } from "Any/Index";
    import { Omit as OOmit } from "Object/Omit";
    import { LastIndex } from "List/LastIndex";
    import { List } from "List/List";
    /**
     * @hidden
     */
    type _Omit<O, Path extends List<Index>, I extends Iteration = IterationOf<'0'>> = O extends object ? Pos<I> extends LastIndex<Path> ? OOmit<O, Path[Pos<I>]> : {
        [K in keyof O]: K extends Path[Pos<I>] ? _Omit<O[K], Path, Next<I>> : O[K];
    } & {} : O;
    /** Remove out of **`O`** the fields at **`Path`**
     * (⚠️ this type is expensive)
     * @param O to remove from
     * @param Path to be followed
     * @returns **`object`**
     * @example
     * ```ts
     * ```
     */
    export type Omit<O extends object, Path extends PPath> = _Omit<O, Path>;
}
declare module "Object/P/Pick" {
    import { IterationOf } from "Iteration/IterationOf";
    import { Iteration } from "Iteration/Iteration";
    import { Pos } from "Iteration/Pos";
    import { Next } from "Iteration/Next";
    import { Path as PPath } from "Object/P/_Internal";
    import { Index } from "Any/Index";
    import { Pick as OPick } from "Object/Pick";
    import { LastIndex } from "List/LastIndex";
    import { List } from "List/List";
    /**
     * @hidden
     */
    type _Pick<O, Path extends List<Index>, I extends Iteration = IterationOf<'0'>> = O extends object ? OPick<O, Path[Pos<I>]> extends infer Picked ? Pos<I> extends LastIndex<Path> ? Picked : {
        [K in keyof Picked]: _Pick<Picked[K], Path, Next<I>>;
    } & {} : never : O;
    /** Extract out of **`O`** the fields at **`Path`**
     * (⚠️ this type is expensive)
     * @param O to extract from
     * @param Path to be followed
     * @returns **`object`**
     * @example
     * ```ts
     * ```
     */
    export type Pick<O extends object, Path extends PPath> = _Pick<O, Path>;
}
declare module "Object/Readonly" {
    import { Merge } from "Object/Merge";
    import { Pick } from "Object/Pick";
    import { Depth } from "Object/_Internal";
    import { Index } from "Any/Index";
    import { Implements } from "Any/Implements";
    /**
     * @hidden
     */
    type ReadonlyFlat<O> = {
        +readonly [K in keyof O]: O[K];
    } & {};
    /**
     * @hidden
     */
    type ReadonlyDeep<O> = {
        +readonly [K in keyof O]: ReadonlyDeep<O[K]>;
    };
    /**
     * @hidden
     */
    type ReadonlyPart<O extends object, depth extends Depth> = {
        'flat': ReadonlyFlat<O>;
        'deep': ReadonlyDeep<O>;
    }[depth];
    /** Make some fields of **`O`** readonly (deeply or not)
     * @param O to make readonly
     * @param K to choose fields (?=`keyof O`)
     * @param depth to do it deeply (?=`'default'`)
     * @returns **`object`**
     * @example
     * ```ts
     * ```
     */
    export type Readonly<O extends object, K extends Index = keyof O, depth extends Depth = 'flat'> = {
        1: ReadonlyPart<O, depth>;
        0: Merge<ReadonlyPart<Pick<O, K>, depth>, O>;
    }[Implements<keyof O, K>];
}
declare module "Object/P/Readonly" {
    import { IterationOf } from "Iteration/IterationOf";
    import { Iteration } from "Iteration/Iteration";
    import { Pos } from "Iteration/Pos";
    import { Next } from "Iteration/Next";
    import { Path as PPath } from "Object/P/_Internal";
    import { Index } from "Any/Index";
    import { Readonly as OReadonly } from "Object/Readonly";
    import { LastIndex } from "List/LastIndex";
    import { List } from "List/List";
    import { Depth } from "Object/_Internal";
    /**
     * @hidden
     */
    type _Readonly<O, Path extends List<Index>, depth extends Depth, I extends Iteration = IterationOf<'0'>> = O extends object ? Pos<I> extends LastIndex<Path> ? OReadonly<O, Path[Pos<I>], depth> : {
        [K in keyof O]: K extends Path[Pos<I>] ? _Readonly<O[K], Path, depth, Next<I>> : O[K];
    } & {} : O;
    /** Make some fields of **`O`** readonly at **`Path`** (deeply or not)
     * (⚠️ this type is expensive)
     * @param O to make readonly
     * @param Path to be followed
     * @param depth to do it deeply (?=`'flat'`)
     * @returns **`object`**
     * @example
     * ```ts
     * ```
     */
    export type Readonly<O extends object, Path extends PPath, depth extends Depth = 'flat'> = _Readonly<O, Path, depth>;
}
declare module "Object/Update" {
    import { Index } from "Any/Index";
    import { x } from "Any/x";
    import { Replace } from "Union/Replace";
    /** Update in **`O`** the fields of key **`K`** with **`A`**.
     * Use the [[x]] placeholder to get the current field type.
     * @param O to update
     * @param K to chose fields
     * @param A to update with
     * @returns **`object`**
     * @example
     * ```ts
     * import {A, O} from 'ts-toolbelt'
     *
     * type User = {
     *     info: {
     *         name: string
     *         age: number
     *         payment: {}
     *     }
     *     id: number
     * }
     *
     * type test0 = Update<User, 'id' | 'info', A.x | null>
     * // {
     * //     info: {
     * //         name: string;
     * //         age: number;
     * //         payment: {};
     * //     } | null;
     * //     id: number | null;
     * // }
     * ```
     */
    export type Update<O extends object, K extends Index, A extends any> = {
        [P in keyof O]: P extends K ? Replace<A, x, O[P]> : O[P];
    } & {};
}
declare module "Object/P/Update" {
    import { IterationOf } from "Iteration/IterationOf";
    import { Iteration } from "Iteration/Iteration";
    import { Pos } from "Iteration/Pos";
    import { Next } from "Iteration/Next";
    import { Path as PPath } from "Object/P/_Internal";
    import { Index } from "Any/Index";
    import { Update as OUpdate } from "Object/Update";
    import { LastIndex } from "List/LastIndex";
    import { List } from "List/List";
    /**
     * @hidden
     */
    type _Update<O, Path extends List<Index>, A, I extends Iteration = IterationOf<'0'>> = O extends object ? Pos<I> extends LastIndex<Path> ? OUpdate<O, Path[Pos<I>], A> : {
        [K in keyof O]: K extends Path[Pos<I>] ? _Update<O[K], Path, A, Next<I>> : O[K];
    } & {} : O;
    /** Update in **`O`** the fields at **`Path`** with **`A`**
     * (⚠️ this type is expensive)
     * @param O to update
     * @param Path to be followed
     * @param A to update with
     * @returns **`object`**
     * @example
     * ```ts
     * ```
     */
    export type Update<O extends object, Path extends PPath, A extends any> = _Update<O, Path, A>;
}
declare module "Object/P/_api" {
    export { Merge } from "Object/P/Merge";
    export { Omit } from "Object/P/Omit";
    export { Pick } from "Object/P/Pick";
    export { Readonly } from "Object/P/Readonly";
    export { Update } from "Object/P/Update";
}
declare module "Object/Assign" {
    import { Iteration } from "Iteration/Iteration";
    import { IterationOf } from "Iteration/IterationOf";
    import { Merge } from "Object/Merge";
    import { Pos } from "Iteration/Pos";
    import { Next } from "Iteration/Next";
    import { Length } from "List/Length";
    import { Cast } from "Any/Cast";
    import { List } from "List/List";
    /**
     * @hidden
     */
    type _Assign<O extends object, Os extends List<object>, I extends Iteration = IterationOf<'0'>> = {
        0: _Assign<Merge<Os[Pos<I>], O>, Os, Next<I>>;
        1: O;
    }[Pos<I> extends Length<Os> ? 1 : 0];
    /** Assign a list of **`object`** into **`O`** with [[Merge]] (last-in overrides)
     * @param O to assign to
     * @param Os to assign
     * @returns **`object`**
     * @example
     * ```ts
     * ```
     */
    export type Assign<O extends object, Os extends List<object>> = _Assign<O, Os> extends infer X ? Cast<X, object> : never;
}
declare module "Object/NullableKeys" {
    import { Index } from "Any/Index";
    /** Get the keys of **`O`** that are nullable
     * @param O
     * @returns **`keyof`**
     * @example
     * ```ts
     * ```
     */
    export type NullableKeys<O extends object> = {
        [K in keyof O]: [O[K] & (undefined | null)] extends [never] ? never : K;
    }[keyof O] & keyof O & Index;
}
declare module "Object/OptionalKeys" {
    import { NonNullable } from "Object/NonNullable";
    import { NullableKeys } from "Object/NullableKeys";
    import { Index } from "Any/Index";
    /** Get the keys of **`O`** that are optional
     * @param O
     * @returns **`keyof`**
     * @example
     * ```ts
     * ```
     */
    export type OptionalKeys<O extends object> = NullableKeys<NonNullable<O>> & keyof O & Index;
}
declare module "Object/MergeUp" {
    import { At } from "Object/At";
    import { Depth } from "Object/_Internal";
    import { Kind } from "Any/Kind";
    import { OptionalKeys } from "Object/OptionalKeys";
    import { Index } from "Any/Index";
    import { NonNullable } from "Union/NonNullable";
    import { And } from "Boolean/And";
    import { Extends } from "Any/Extends";
    import { True, Boolean, False } from "Boolean/Boolean";
    import { Or } from "Boolean/Or";
    /**
     * @hidden
     */
    type MergeUpProp<O extends object, O1 extends object, K extends Index, IsOptional extends Boolean> = IsOptional extends True ? NonNullable<At<O, K>> | At<O1, K> : [At<O, K>] extends [never] ? At<O1, K> : At<O, K>;
    /**
     * @hidden
     */
    type _MergeUpFlat<O extends object, O1 extends object, OOK extends Index = OptionalKeys<O>> = {
        [K in keyof (O & O1)]: MergeUpProp<O, O1, K, Extends<K, OOK>>;
    } & {};
    /**
     * @hidden
     */
    type MergeUpFlat<O extends object, O1 extends object> = O extends unknown ? O1 extends unknown ? _MergeUpFlat<O, O1> : never : never;
    /**
     * @hidden
     */
    type _MergeUpDeep<O extends object, O1 extends object, IsParentOptional extends Boolean = 0> = {
        [K in keyof (O & O1)]: And<// we first make sure that both are objects
        Extends<Kind<NonNullable<At<O, K>>>, 'object'>, Extends<Kind<NonNullable<At<O1, K>>>, 'object'>> extends True ? _MergeUpDeep<// if it is the case, recurse deeper
        // if it is the case, recurse deeper
        At<O, K> & {}, // merge O[K]
        // merge O[K]
        At<O1, K> & {}, // with O1[K]
        K extends True ? K : K extends OptionalKeys<O> ? True : False> : MergeUpProp<// otherwise, we treat them as fields
        O, O1, K, Or<// if parent, or the field `K` are optional
        IsParentOptional, Extends<K, OptionalKeys<O>>>>;
    };
    /**
     * @hidden
     */
    type MergeUpDeep<O extends object, O1 extends object> = O extends unknown ? O1 extends unknown ? _MergeUpDeep<O, O1> : never : never;
    /** Accurately complete the fields of **`O`** with the ones of **`O1`**.
     * This is a version of `Merge` that handles optional fields. It understands
     * that merged optional fields are no longer optional (have been completed).
     * It is able to deal with the merging of **`Union`s** of **`object`**s.
     * @param O to complete
     * @param O1 to copy from
     * @param depth to do it deeply (?=`'flat'`)
     * @returns **`object`**
     * @example
     * ```ts
     * import {O} from 'ts-toolbelt'
     *
     * type O = {
     *     name?: string
     *     age? : number
     *     zip? : string
     *     pay  : {
     *         cvv?: number
     *     }
     * }
     *
     * type O1 = {
     *     age : number
     *     zip?: number
     *     city: string
     *     pay : {
     *         cvv : number
     *         ccn?: string
     *     }
     * }
     *
     * type test = O.MergeUp<O, O1, 'deep'>
     * // {
     * //     name?: string | undefined;
     * //     age: number;
     * //     zip?: string | number;
     * //     pay: {
     * //         cvv: number;
     * //         ccn?: string | undefined;
     * //     };
     * //     city: string;
     * // }
     * ```
     */
    export type MergeUp<O extends object, O1 extends object, depth extends Depth = 'flat'> = {
        'flat': MergeUpFlat<O, O1>;
        'deep': MergeUpDeep<O, O1>;
    }[depth];
}
declare module "Object/AssignUp" {
    import { Iteration } from "Iteration/Iteration";
    import { IterationOf } from "Iteration/IterationOf";
    import { MergeUp } from "Object/MergeUp";
    import { Pos } from "Iteration/Pos";
    import { Next } from "Iteration/Next";
    import { Length } from "List/Length";
    import { Cast } from "Any/Cast";
    import { List } from "List/List";
    /**
     * @hidden
     */
    type _Assign<O extends object, Os extends List<object>, I extends Iteration = IterationOf<'0'>> = {
        0: _Assign<MergeUp<Os[Pos<I>], O>, Os, Next<I>>;
        1: O;
    }[Pos<I> extends Length<Os> ? 1 : 0];
    /** Assign a list of **`object`** into **`O`** with [[MergeUp]] (last-in combines or overrides)
     * @param O to assign to
     * @param Os to assign
     * @returns **`object`**
     * @example
     * ```ts
     * ```
     */
    export type AssignUp<O extends object, Os extends List<object>> = _Assign<O, Os> extends infer X ? Cast<X, object> : never;
}
declare module "Object/Compulsory" {
    import { Merge } from "Object/Merge";
    import { Pick } from "Object/Pick";
    import { Depth } from "Object/_Internal";
    import { Index } from "Any/Index";
    import { Implements } from "Any/Implements";
    import { NonNullable } from "Union/NonNullable";
    /**
     * @hidden
     */
    type CompulsoryFlat<O> = {
        [K in keyof O]-?: NonNullable<O[K]>;
    } & {};
    /**
     * @hidden
     */
    type CompulsoryDeep<O> = {
        [K in keyof O]-?: CompulsoryDeep<NonNullable<O[K]>>;
    };
    /**
     * @hidden
     */
    type CompulsoryPart<O extends object, depth extends Depth> = {
        'flat': CompulsoryFlat<O>;
        'deep': CompulsoryDeep<O>;
    }[depth];
    /** Make some fields of **`O`** compulsory (deeply or not)
     * (it's like [[Required]] & [[NonNullable]] at once).
     * @param O to make compulsory
     * @param K to choose fields (?=`keyof O`)
     * @param depth to do it deeply (?=`'flat'`)
     * @returns **`object`**
     * @example
     * ```ts
     * ```
     */
    export type Compulsory<O extends object, K extends Index = keyof O, depth extends Depth = 'flat'> = {
        1: CompulsoryPart<O, depth>;
        0: Merge<CompulsoryPart<Pick<O, K>, depth>, O>;
    }[Implements<keyof O, K>];
}
declare module "Object/CompulsoryKeys" {
    import { Index } from "Any/Index";
    /** Get the keys of **`O`** that are compulsory
     * @param O
     * @returns **`keyof`**
     * @example
     * ```ts
     * ```
     */
    export type CompulsoryKeys<O extends object> = {
        [K in keyof O]: [O[K] & (undefined | null)] extends [never] ? K : never;
    }[keyof O] & keyof O & Index;
}
declare module "Object/ExcludeKeys" {
    import { Exclude } from "Union/Exclude";
    import { Match } from "Any/_Internal";
    import { Is } from "Any/Is";
    import { At } from "Object/At";
    import { Index } from "Any/Index";
    /**
     * @hidden
     */
    type ExcludeMatch<O extends object, O1 extends object, match extends Match> = {
        [K in keyof O]: {
            1: never;
            0: K;
        }[Is<O[K], At<O1, K>, match>];
    }[keyof O] & keyof O & Index;
    /** Exclude the keys of **`O1`** out of the keys of **`O`**
     * (If `match = 'default'`, no type checks are done)
     * @param O to remove the keys from
     * @param O1 to remove the keys out
     * @param match to change precision (?=`'default'`)
     * @returns **`keyof`**
     * @example
     * ```ts
     * ```
     */
    export type ExcludeKeys<O extends object, O1 extends object, match extends Match = 'default'> = {
        'default': Exclude<keyof O, keyof O1>;
        'implements->': ExcludeMatch<O, O1, 'implements->'>;
        'extends->': ExcludeMatch<O, O1, 'extends->'>;
        '<-implements': ExcludeMatch<O, O1, '<-implements'>;
        '<-extends': ExcludeMatch<O, O1, '<-extends'>;
        'equals': ExcludeMatch<O, O1, 'equals'>;
    }[match];
}
declare module "Object/Exclude" {
    import { ExcludeKeys } from "Object/ExcludeKeys";
    import { Match } from "Any/_Internal";
    import { Pick } from "Object/Pick";
    /** Exclude the fields of **`O1`** out of **`O`**
     * (If `match = 'default'`, no type checks are done)
     * @param O to remove from
     * @param O1 to remove out
     * @param match to change precision (?=`'default'`)
     * @returns **`object`**
     * @example
     * ```ts
     * ```
     */
    export type Exclude<O extends object, O1 extends object, match extends Match = 'default'> = Pick<O, ExcludeKeys<O, O1, match>>;
}
declare module "Object/Diff" {
    import { Merge } from "Object/Merge";
    import { Exclude } from "Object/Exclude";
    import { Match } from "Any/_Internal";
    /** Get an **`object`** that is the difference between **`O`** & **`O1`**
     * (**`O`**'s differences have priority over **`O1`**'s if fields overlap)
     * (If `match = 'default'`, no type checks are done)
     * @param O to check differences with
     * @param O1 to check differences against
     * @param match to change precision (?=`'default'`)
     * @returns **`object`**
     * @example
     * ```ts
     * import {O} from 'ts-toolbelt'
     *
     * type Person0 = {
     *     name: string
     *     age: string
     * }
     *
     * type Person1 = {
     *     name: string
     *     age: number | string
     *     nick: string
     * }
     *
     * type test0 = O.Diff<Person0, Person1, 'default'>   // {nick: string}
     * type test1 = O.Diff<Person0, Person1, 'extends->'> // {nick: string; age: string | number}
     * type test2 = O.Diff<Person0, Person1, '<-extends'> // {nick: string; age: string}
     * type test3 = O.Diff<Person0, Person1, 'equals'>    // {nick: string; age: string}
     * ```
     */
    export type Diff<O extends object, O1 extends object, match extends Match = 'default'> = Merge<Exclude<O, O1, match>, Exclude<O1, O, match>>;
}
declare module "Object/Either" {
    import { Omit } from "Object/Omit";
    import { Pick } from "Object/Pick";
    import { Index } from "Any/Index";
    import { Strict } from "Union/Strict";
    import { Boolean, True } from "Boolean/Boolean";
    import { Compute } from "Any/Compute";
    /**
     * @hidden
     */
    type _Either<O extends object, K extends Index> = Omit<O, K> & {
        [P in K]: Pick<O, P>;
    }[K];
    /**
     * @hidden
     */
    type EitherStrict<O extends object, K extends Index> = Strict<_Either<O, K>> & {};
    /**
     * @hidden
     */
    type EitherLoose<O extends object, K extends Index> = Compute<_Either<O, K>> & {};
    /** Split **`O`** into a [[Union]] with **`K`** keys in such a way that none of
     * the keys are ever present with one another within the different unions.
     * @param O to split
     * @param K to split with
     * @param strict to force excess property checks (?=`True`) https://github.com/microsoft/TypeScript/issues/20863
     * @returns **`object`** [[Union]]
     * @example
     * ```ts
     * ```
     */
    export type Either<O extends object, K extends Index, strict extends Boolean = True> = {
        1: EitherStrict<O, K>;
        0: EitherLoose<O, K>;
    }[strict];
}
declare module "Object/FilterKeys" {
    import { Match } from "Any/_Internal";
    import { Is } from "Any/Is";
    import { Index } from "Any/Index";
    /** Filter out the keys of **`O`** which fields match **`M`**
     * @param O to remove from
     * @param M to select fields
     * @param match to change precision (?=`'default'`)
     * @returns **`keyof`**
     * @example
     * ```ts
     * ```
     */
    export type FilterKeys<O extends object, M extends any, match extends Match = 'default'> = {
        [K in keyof O]: {
            1: never;
            0: K;
        }[Is<O[K], M, match>];
    }[keyof O] & keyof O & Index;
}
declare module "Object/Filter" {
    import { FilterKeys } from "Object/FilterKeys";
    import { Match } from "Any/_Internal";
    import { Pick } from "Object/Pick";
    /** Filter out of **`O`** the fields that match **`M`**
     * @param O to remove from
     * @param M to select fields
     * @param match to change precision (?=`'default'`)
     * @returns **`object`**
     * @example
     * ```ts
     * ```
     */
    export type Filter<O extends object, M extends any, match extends Match = 'default'> = Pick<O, FilterKeys<O, M, match>>;
}
declare module "Object/Has" {
    import { Match } from "Any/_Internal";
    import { Is } from "Any/Is";
    import { At } from "Object/At";
    import { Index } from "Any/Index";
    /** Check whether **`O`** has a field of key **`K`** that matches **`M`**
     * @param O to be inspected
     * @param K to choose field
     * @param M to check field type (?=`any`)
     * @param match to change precision (?=`'default'`)
     * @returns [[Boolean]]
     * @example
     * ```ts
     * ```
     */
    export type Has<O extends object, K extends Index, M extends any = any, match extends Match = 'default'> = Is<At<O, K>, M, match>;
}
declare module "Object/Path" {
    import { IterationOf } from "Iteration/IterationOf";
    import { Iteration } from "Iteration/Iteration";
    import { Next } from "Iteration/Next";
    import { Pos } from "Iteration/Pos";
    import { Length } from "List/Length";
    import { At } from "Object/At";
    import { Cast } from "Any/Cast";
    import { NonNullable as UNonNullable } from "Union/NonNullable";
    import { Index } from "Any/Index";
    import { List } from "List/List";
    /**
     * @hidden
     */
    type _Path<O, Path extends List<Index>, I extends Iteration = IterationOf<'0'>> = {
        0: _Path<UNonNullable<At<O & {}, Path[Pos<I>]>>, Path, Next<I>>;
        1: O;
    }[Pos<I> extends Length<Path> ? 1 : 0];
    /** Get in **`O`** the type of nested properties
     * For more advanced capabilities, see [[PathUp]]
     * @param O to be inspected
     * @param Path to be followed
     * @returns **`any`**
     * @example
     * ```ts
     * ```
     */
    export type Path<O extends object, Path extends List<Index>> = _Path<O, Path> extends infer X ? Cast<X, any> : never;
}
declare module "Object/HasPath" {
    import { Match } from "Any/_Internal";
    import { Path as OPath } from "Object/Path";
    import { Is } from "Any/Is";
    import { Index } from "Any/Index";
    import { List } from "List/List";
    /** Check whether **`O`** has nested properties that match **`M`**
     * @param O to be inspected
     * @param Path to be followed
     * @param M to check field type (?=`any`)
     * @param match to change precision (?=`'default'`)
     * @returns [[Boolean]]
     * @example
     * ```ts
     * ```
     */
    export type HasPath<O extends object, Path extends List<Index>, M extends any = any, match extends Match = 'default'> = Is<OPath<O, Path>, M, match>;
}
declare module "Object/SelectKeys" {
    import { Match } from "Any/_Internal";
    import { Is } from "Any/Is";
    import { Index } from "Any/Index";
    /** Get the keys of **`O`** which fields match **`M`**
     * @param O to extract from
     * @param M to select fields
     * @param match to change precision (?=`'default'`)
     * @returns **`keyof`**
     * @example
     * ```ts
     * ```
     */
    export type SelectKeys<O extends object, M extends any, match extends Match = 'default'> = {
        [K in keyof O]: {
            1: K;
            0: never;
        }[Is<O[K], M, match>];
    }[keyof O] & keyof O & Index;
}
declare module "Object/Includes" {
    import { SelectKeys } from "Object/SelectKeys";
    import { Match } from "Any/_Internal";
    import { False, True } from "Boolean/Boolean";
    /** Check whether **`O`** has fields that match **`M`**
     * @param O to be inspected
     * @param M to check field type
     * @param match to change precision (?=`'default'`)
     * @returns [[Boolean]]
     * @example
     * ```ts
     * ```
     */
    export type Includes<O extends object, M extends any, match extends Match = 'default'> = [SelectKeys<O, M, match>] extends [never] ? False : True;
}
declare module "Object/IntersectKeys" {
    import { Intersect } from "Union/Intersect";
    import { Match } from "Any/_Internal";
    import { Is } from "Any/Is";
    import { At } from "Object/At";
    import { Index } from "Any/Index";
    /**
     * @hidden
     */
    type IntersectMatch<O extends object, O1 extends object, match extends Match> = {
        [K in keyof O]: {
            1: K;
            0: never;
        }[Is<O[K], At<O1, K>, match>];
    }[keyof O] & keyof O & Index;
    /** Get the intersecting keys of **`O`** & **`O1`**
     * (If `match = 'default'`, no type checks are done)
     * @param O to check similarities with
     * @param O1 to check similarities against
     * @returns **`keyof`**
     * @example
     * ```ts
     * ```
     */
    export type IntersectKeys<O extends object, O1 extends object, match extends Match = 'default'> = {
        'default': Intersect<keyof O, keyof O1>;
        'implements->': IntersectMatch<O, O1, 'implements->'>;
        'extends->': IntersectMatch<O, O1, 'extends->'>;
        '<-implements': IntersectMatch<O, O1, '<-implements'>;
        '<-extends': IntersectMatch<O, O1, '<-extends'>;
        'equals': IntersectMatch<O, O1, 'equals'>;
    }[match];
}
declare module "Object/Intersect" {
    import { IntersectKeys } from "Object/IntersectKeys";
    import { Match } from "Any/_Internal";
    import { Pick } from "Object/Pick";
    /** Get the intersecting fields of **`O`** & **`O1`**
     * (If `match = 'default'`, no type checks are done)
     * @param O to check similarities with
     * @param O1 to check similarities against
     * @returns **`object`**
     * @example
     * ```ts
     * ```
     */
    export type Intersect<O extends object, O1 extends object, match extends Match = 'default'> = Pick<O, IntersectKeys<O, O1, match>>;
}
declare module "Object/Invert" {
    import { Record } from "Object/Record";
    import { Index } from "Any/Index";
    import { IntersectOf } from "Union/IntersectOf";
    import { Compute } from "Any/Compute";
    /** Swaps the keys and values of an **`object`** (if applicable)
     * @param O
     * @returns **`object`**
     * @example
     * ```ts
     * import {O} from 'ts-toolbelt'
     *
     * enum E {
     *     A = 'Av',
     *     B = 'Bv',
     *     C = 'Cv',
     *     D = 'Dv',
     *     X = 1
     * }
     *
     * type O = {
     *     A: 'Av'
     *     B: 'Bv'
     *     C: 'Cv'
     *     D: 'Dv'
     *     X: 1
     * }
     *
     * type test0 = O.Invert<typeof E>
     * type test1 = O.Invert<O>
     * ```
     */
    export type Invert<O extends Record<keyof O, Index>> = Compute<IntersectOf<{
        [K in keyof O]: Record<O[K], K>;
    }[keyof O]>>;
}
declare module "Object/Keys" {
    import { Index } from "Any/Index";
    /** Get the keys of an **`object`**
     * @param O
     * @returns **`keyof`**
     * @example
     * ```ts
     * ```
     */
    export type Keys<O extends object> = keyof O & Index;
}
declare module "Object/Modify" {
    import { At } from "Object/At";
    import { Replace } from "Union/Replace";
    import { x } from "Any/x";
    import { Exclude } from "Union/Exclude";
    /** Modify **`O`** with **`OMod`** & the [[x]] placeholder
     * @param O to copy from
     * @param OMod to copy to
     * @returns **`object`**
     * @example
     * ```ts
     * ```
     */
    export type Modify<O extends object, OMod extends object> = {
        [K in keyof OMod]: Replace<OMod[K], x, Exclude<At<O, K>, undefined>>;
    } & {};
}
declare module "Object/NonNullableKeys" {
    import { Index } from "Any/Index";
    /** Get the keys of **`O`** that are non-nullable
     * @param O
     * @returns **`keyof`**
     * @example
     * ```ts
     * ```
     */
    export type NonNullableKeys<O extends object> = {
        [K in keyof O]: [O[K] & (undefined | null)] extends [never] ? K : never;
    }[keyof O] & keyof O & Index;
}
declare module "Object/Nullable" {
    import { Merge } from "Object/Merge";
    import { Nullable as UNullable } from "Union/Nullable";
    import { Depth } from "Object/_Internal";
    import { Pick } from "Object/Pick";
    import { Index } from "Any/Index";
    import { Implements } from "Any/Implements";
    /**
     * @hidden
     */
    type NullableFlat<O> = {
        [K in keyof O]: UNullable<O[K]>;
    } & {};
    /**
     * @hidden
     */
    type NullableDeep<O> = {
        [K in keyof O]: NullableDeep<UNullable<O[K]>>;
    };
    /**
     * @hidden
     */
    type NullablePart<O extends object, depth extends Depth> = {
        'flat': NullableFlat<O>;
        'deep': NullableDeep<O>;
    }[depth];
    /** Make some fields of **`O`** nullable (deeply or not)
     * @param O to make nullable
     * @param K to choose fields (?=`keyof O`)
     * @param depth to do it deeply (?=`'flat'`)
     * @returns **`object`**
     * @example
     * ```ts
     * ```
     */
    export type Nullable<O extends object, K extends Index = keyof O, depth extends Depth = 'flat'> = {
        1: NullablePart<O, depth>;
        0: Merge<NullablePart<Pick<O, K>, depth>, O>;
    }[Implements<keyof O, K>];
}
declare module "List/Optional" {
    import { Optional as OOptional } from "Object/Optional";
    import { Depth } from "Object/_Internal";
    import { Cast } from "Any/Cast";
    import { List } from "List/List";
    /** Make **`T`** optional (deeply or not)
     * @param T to make optional
     * @param depth to do it deeply (?=`'flat'`)
     * @returns **`any[]`**
     * @example
     * ```ts
     * ```
     */
    export type Optional<T extends List, depth extends Depth = 'flat'> = Cast<OOptional<T, keyof T, depth>, List>;
}
declare module "Object/Paths" {
    import { Prepend } from "List/Prepend";
    import { Reverse } from "List/Reverse";
    import { Optional } from "List/Optional";
    import { Index } from "Any/Index";
    import { NonNullable } from "List/NonNullable";
    import { Concat } from "List/Concat";
    import { Cast } from "Any/Cast";
    import { Equals } from "Any/Equals";
    import { True } from "Boolean/Boolean";
    import { List } from "List/List";
    /**
     * @hidden
     */
    type _Paths<O, Paths extends List<Index> = []> = {
        0: {
            [K in keyof O]: _Paths<O[K], Prepend<Paths, K>>;
        }[keyof O];
        1: NonNullable<Optional<Reverse<Paths>>>;
        2: NonNullable<Optional<Concat<Reverse<Paths>, Index[]>>>;
    }[Equals<O, any> extends True ? 2 : O extends object ? [keyof O] extends [never] ? 1 : 0 : 1];
    /** Get all the possible paths of **`O`**
     * (⚠️ this won't work with circular-refs)
     * @param O to be inspected
     * @returns **`string[]`**
     * @example
     * ```ts
     * ```
     */
    export type Paths<O extends object> = _Paths<O> extends infer X ? Cast<X, List<Index>> : never;
}
declare module "Object/PathUp" {
    import { IterationOf } from "Iteration/IterationOf";
    import { Iteration } from "Iteration/Iteration";
    import { Next } from "Iteration/Next";
    import { Pos } from "Iteration/Pos";
    import { Length } from "List/Length";
    import { At } from "Object/At";
    import { Cast } from "Any/Cast";
    import { NonNullable as UNonNullable } from "Union/NonNullable";
    import { Index } from "Any/Index";
    import { List } from "List/List";
    /**
     * @hidden
     */
    type _PathUp<O, Path extends List<Index>, I extends Iteration = IterationOf<'0'>> = {
        0: O extends unknown ? At<O & {}, Path[Pos<I>]> extends infer OK ? _PathUp<UNonNullable<OK>, Path, Next<I>> : never : never;
        1: O;
    }[Pos<I> extends Length<Path> ? 1 : 0];
    /** Get in **`O`** the type of nested properties.
     * It is able to deal with nested [[Union]]s.
     * @param O to be inspected
     * @param Path to be followed
     * @returns **`any`**
     * @example
     * ```ts
     * ```
     */
    export type PathUp<O extends object, Path extends List<Index>> = _PathUp<O, Path> extends infer X ? Cast<X, any> : never;
}
declare module "List/Update" {
    import { Update as OUpdate } from "Object/Update";
    import { Cast } from "Any/Cast";
    import { Index } from "Any/Index";
    import { List } from "List/List";
    /** Update in **`T`** the entries of key **`K`** with **`A`**.
     * Use the [[x]] placeholder to get the current field type.
     * @param T to update
     * @param K to chose fields
     * @param A to update with
     * @returns **`any[]`**
     * @example
     * ```ts
     * ```
     */
    export type Update<T extends List, K extends Index, A extends any> = Cast<OUpdate<T, K, A>, List>;
}
declare module "List/UnionOf" {
    import { List } from "List/List";
    /** Transform a [[List]] into an [[Union]]
     * @param T to transform
     * @returns **`any`**
     * @example
     * ```ts
     * ```
     */
    export type UnionOf<T extends List> = T[number];
}
declare module "List/KeySet" {
    import { Number } from "Number/Number";
    import { Range } from "Number/Range";
    import { UnionOf } from "List/UnionOf";
    /** Create a set of keys
     * @param From to start with
     * @param To to end with
     * @returns **`keyof`**
     * @example
     * ```ts
     * ```
     */
    export type KeySet<From extends Number, To extends Number> = UnionOf<Range<From, To, '->'>>;
}
declare module "Object/PathValid" {
    import { IterationOf } from "Iteration/IterationOf";
    import { Iteration } from "Iteration/Iteration";
    import { Next } from "Iteration/Next";
    import { Pos } from "Iteration/Pos";
    import { Length } from "List/Length";
    import { At } from "Object/At";
    import { Cast } from "Any/Cast";
    import { NonNullable as UNonNullable } from "Union/NonNullable";
    import { Update } from "List/Update";
    import { KeySet } from "List/KeySet";
    import { Key } from "Iteration/Key";
    import { Prev } from "Iteration/Prev";
    import { Index } from "Any/Index";
    import { List } from "List/List";
    /**
     * @hidden
     */
    type _PathValid<O, Path extends List<Index>, I extends Iteration = IterationOf<'0'>> = {
        0: _PathValid<UNonNullable<At<O & {}, Path[Pos<I>]>>, Path, Next<I>>;
        1: Update<Path, KeySet<Key<Prev<I>>, Length<Path, 's'>>, never>;
    }[[O] extends [never] ? 1 : 0];
    /** Replaces invalid parts of a path with `never`
     * @param O to be inspected
     * @param Path to be validated
     * @returns **`Index[]`**
     * @example
     * ```ts
     * import {A, T, O} from 'ts-toolbelt'
     *
     * // Get a property in an object `o` at any depth with `path`
     * // `A.Cast<P, O.PathValid<O, P>>` makes sure `path` is valid
     * const getAt = <
     * O extends object,
     * P extends L.List<A.Index>
     * >(o: O, path: A.Cast<P, O.PathValid<O, P>>): O.Path<O, P> => {
     *     let valueAt = o
     *
     *     for (const p of path)
     *         valueAt = valueAt[p]
     *
     *     return valueAt as any
     * }
     *
     * const test0 = getAt({a: {b: {c: 1}}},          ['a', 'b'] as const) // {c: number}
     * const test1 = getAt({a: {b: {c: 1}}} as const, ['a', 'b'] as const) // {c: 1}
     * const test2 = getAt({a: {b: {c: 1}}},          ['x'] as const)      // error
     * ```
     */
    export type PathValid<O extends object, Path extends List<Index>> = _PathValid<O, Path> extends infer X ? Cast<X, List<Index>> : never;
}
declare module "Object/ReadonlyKeys" {
    import { Equals } from "Any/Equals";
    import { Index } from "Any/Index";
    /** Get the keys of **`O`** that are readonly
     * @param O
     * @returns **`keyof`**
     * @example
     * ```ts
     * ```
     */
    export type ReadonlyKeys<O extends object> = {
        [K in keyof O]-?: {
            1: never;
            0: K;
        }[Equals<{
            -readonly [Q in K]: O[K];
        }, {
            [Q in K]: O[K];
        }>];
    }[keyof O] & keyof O & Index;
}
declare module "Object/Replace" {
    import { Match } from "Any/_Internal";
    import { Is } from "Any/Is";
    /** Update with **`A`** the fields of **`O`** that match **`M`**
     * @param O to update
     * @param M to select fields
     * @param A to update with
     * @param match to change precision (?=`'default'`)
     * @returns **`object`**
     * @example
     * ```ts
     * ```
     */
    export type Replace<O extends object, M extends any, A extends any, match extends Match = 'default'> = {
        [K in keyof O]: {
            1: A;
            0: O[K];
        }[Is<M, O[K], match>];
    } & {};
}
declare module "Object/RequiredKeys" {
    import { NonNullableKeys } from "Object/NonNullableKeys";
    import { NonNullable } from "Object/NonNullable";
    import { Index } from "Any/Index";
    /** Get the keys of **`O`** that are required
     * @param O
     * @returns **`keyof`**
     * @example
     * ```ts
     * ```
     */
    export type RequiredKeys<O extends object> = NonNullableKeys<NonNullable<O>> & keyof O & Index;
}
declare module "Object/Select" {
    import { SelectKeys } from "Object/SelectKeys";
    import { Match } from "Any/_Internal";
    import { Pick } from "Object/Pick";
    /** Extract the fields of **`O`** that match **`M`**
     * @param O to extract from
     * @param M to select fields
     * @param match to change precision (?=`'default'`)
     * @returns **`object`**
     * @example
     * ```ts
     * ```
     */
    export type Select<O extends object, M extends any, match extends Match = 'default'> = Pick<O, SelectKeys<O, M, match>>;
}
declare module "Object/Unionize" {
    import { At } from "Object/At";
    import { Index } from "Any/Index";
    /** Make the fields of **`O`** union the ones of **`O1`**
     * @param O to union from
     * @param O1 to union with
     * @param K to chose fields (?=`keyof O`)
     * @returns **`object`**
     * @example
     * ```ts
     * ```
     */
    export type Unionize<O extends object, O1 extends object, K extends Index = keyof O> = {
        [P in keyof O]: P extends K ? O[P] | At<O1, P> : O[P];
    } & {};
}
declare module "Object/UnionOf" {
    /** Transform an **`object`** into an [[Union]]
     * @param O to transform
     * @returns **`any`**
     * @example
     * ```ts
     * ```
     */
    export type UnionOf<O extends object> = O[keyof O];
}
declare module "Object/Writable" {
    import { Pick } from "Object/Pick";
    import { Depth } from "Object/_Internal";
    import { Merge } from "Object/Merge";
    import { Index } from "Any/Index";
    import { Implements } from "Any/Implements";
    /**
     * @hidden
     */
    type WritableFlat<O> = {
        -readonly [K in keyof O]: O[K];
    };
    /**
     * @hidden
     */
    type WritableDeep<O> = {
        -readonly [K in keyof O]: WritableDeep<O[K]>;
    };
    /**
     * @hidden
     */
    type WritablePart<O extends object, depth extends Depth> = {
        'flat': WritableFlat<O>;
        'deep': WritableDeep<O>;
    }[depth];
    /** Make some fields of **`O`** writable (deeply or not)
     * @param O to make writable
     * @param K to choose fields (?=`keyof O`)
     * @param depth to do it deeply (?=`'flat'`)
     * @returns **`object`**
     * @example
     * ```ts
     * ```
     */
    export type Writable<O extends object, K extends Index = keyof O, depth extends Depth = 'flat'> = {
        1: WritablePart<O, depth>;
        0: Merge<WritablePart<Pick<O, K>, depth>, O>;
    }[Implements<keyof O, K>];
}
declare module "Object/WritableKeys" {
    import { Equals } from "Any/Equals";
    import { Index } from "Any/Index";
    /** Get the keys of **`O`** that are writable
     * @param O
     * @returns **`keyof`**
     * @example
     * ```ts
     * ```
     */
    export type WritableKeys<O extends object> = {
        [K in keyof O]-?: {
            1: K;
            0: never;
        }[Equals<{
            -readonly [Q in K]: O[K];
        }, {
            [Q in K]: O[K];
        }>];
    }[keyof O] & keyof O & Index;
}
declare module "Object/_api" {
    import * as P from "Object/P/_api";
    export { P };
    export { Assign } from "Object/Assign";
    export { AssignUp } from "Object/AssignUp";
    export { At } from "Object/At";
    export { Compulsory } from "Object/Compulsory";
    export { CompulsoryKeys } from "Object/CompulsoryKeys";
    export { Diff } from "Object/Diff";
    export { Either } from "Object/Either";
    export { Exclude } from "Object/Exclude";
    export { ExcludeKeys } from "Object/ExcludeKeys";
    export { Filter } from "Object/Filter";
    export { FilterKeys } from "Object/FilterKeys";
    export { Has } from "Object/Has";
    export { HasPath } from "Object/HasPath";
    export { Includes } from "Object/Includes";
    export { Intersect } from "Object/Intersect";
    export { IntersectKeys } from "Object/IntersectKeys";
    export { Invert } from "Object/Invert";
    export { Keys } from "Object/Keys";
    export { Merge } from "Object/Merge";
    export { MergeUp } from "Object/MergeUp";
    export { Modify } from "Object/Modify";
    export { NonNullable } from "Object/NonNullable";
    export { NonNullableKeys } from "Object/NonNullableKeys";
    export { Nullable } from "Object/Nullable";
    export { NullableKeys } from "Object/NullableKeys";
    export { Omit } from "Object/Omit";
    export { Optional } from "Object/Optional";
    export { OptionalKeys } from "Object/OptionalKeys";
    export { Overwrite } from "Object/Overwrite";
    export { Path } from "Object/Path";
    export { Paths } from "Object/Paths";
    export { PathUp } from "Object/PathUp";
    export { PathValid } from "Object/PathValid";
    export { Pick } from "Object/Pick";
    export { Readonly } from "Object/Readonly";
    export { ReadonlyKeys } from "Object/ReadonlyKeys";
    export { Record } from "Object/Record";
    export { Replace } from "Object/Replace";
    export { Required } from "Object/Required";
    export { RequiredKeys } from "Object/RequiredKeys";
    export { Select } from "Object/Select";
    export { SelectKeys } from "Object/SelectKeys";
    export { ListOf } from "Object/ListOf";
    export { ListOf as TupleOf } from "Object/ListOf";
    export { Unionize } from "Object/Unionize";
    export { UnionOf } from "Object/UnionOf";
    export { Update } from "Object/Update";
    export { Writable } from "Object/Writable";
    export { WritableKeys } from "Object/WritableKeys";
    export { Clean as Ensure } from "Any/Clean";
}
declare module "String/_api" {
    export { Format } from "String/Format";
}
declare module "List/Omit" {
    import { Omit as OOmit } from "Object/Omit";
    import { ListOf } from "Object/ListOf";
    import { Index } from "Any/Index";
    import { List } from "List/List";
    /** Remove out of **`T`** the entries of key **`K`**
     * @param T to remove from
     * @param K to chose entries
     * @returns **`any[]`**
     * @example
     * ```ts
     * ```
     */
    export type Omit<T extends List, K extends Index> = ListOf<OOmit<T, K | keyof any[]>>;
}
declare module "List/Assign" {
    import { Assign as OAssign } from "Object/Assign";
    import { Omit } from "List/Omit";
    import { List } from "List/List";
    import { ObjectOf } from "List/ObjectOf";
    import { Cast } from "Any/Cast";
    /** Assign a list of [[List]] into **`T`** with `Merge` (last-in overrides)
     * @param T to assign to
     * @param Ts to assign
     * @returns **`object`**
     * @example
     * ```ts
     * ```
     */
    export type Assign<T extends List, Ts extends List[]> = Omit<OAssign<T, {
        [K in keyof Ts]: ObjectOf<Cast<Ts[K], List>>;
    }> & [], keyof any[]>;
}
declare module "List/AssignUp" {
    import { AssignUp as OAssignUp } from "Object/AssignUp";
    import { Omit } from "List/Omit";
    import { List } from "List/List";
    import { ObjectOf } from "List/ObjectOf";
    import { Cast } from "Any/Cast";
    /** Assign a list of [[List]] into **`T`** with [[MergeUp]] (last-in combines or overrides)
     * @param T to assign to
     * @param Ts to assign
     * @returns **`object`**
     * @example
     * ```ts
     * ```
     */
    export type AssignUp<T extends List, Ts extends List<List>> = Omit<OAssignUp<T, {
        [K in keyof Ts]: ObjectOf<Cast<Ts[K], List>>;
    }> & [], keyof any[]>;
}
declare module "List/At" {
    import { At as OAt } from "Object/At";
    import { Index } from "Any/Index";
    import { List } from "List/List";
    /** Get in **`T`** the type of an entry of key **`K`**
     * @param T to extract from
     * @param K to extract at
     * @returns **`any`**
     * @example
     */
    export type At<T extends List, K extends Index> = OAt<T, K>;
}
declare module "List/Compulsory" {
    import { Depth } from "Object/_Internal";
    import { Compulsory as OCompulsory } from "Object/Compulsory";
    import { Cast } from "Any/Cast";
    import { List } from "List/List";
    /** Make **`T`** compulsory (deeply or not)
     * @param T to make compulsory
     * @param depth to do it deeply (?=`'flat'`)
     * @returns **`any[]`**
     * @example
     * ```ts
     * ```
     */
    export type Compulsory<T extends List, depth extends Depth = 'flat'> = Cast<OCompulsory<T, keyof T, depth>, List>;
}
declare module "List/CompulsoryKeys" {
    import { Compulsory as OCompulsory } from "Object/Compulsory";
    import { ObjectOf } from "List/ObjectOf";
    import { List } from "List/List";
    /** Get the keys of **`T`** that are compulsory
     * @param T
     * @returns **`keyof`**
     * @example
     * ```ts
     * ```
     */
    export type CompulsoryKeys<T extends List> = OCompulsory<ObjectOf<T>>;
}
declare module "List/Diff" {
    import { Diff as ODiff } from "Object/Diff";
    import { ListOf } from "Object/ListOf";
    import { Match } from "Any/_Internal";
    import { ObjectOf } from "List/ObjectOf";
    import { List } from "List/List";
    /** Get a [[List]] that is the difference between **`T`** & **`T1`**
     * (**`T`**'s differences have priority over **`T1`**'s if entries overlap)
     * (If `match = 'default'`, no type checks are done)
     * @param T to check differences with
     * @param T1 to check differences against
     * @param match to change precision (?=`'default'`)
     * @returns **`any[]`**
     * @example
     * ```ts
     * ```
     */
    export type Diff<T extends List, T1 extends List, match extends Match = 'default'> = ListOf<ODiff<ObjectOf<T>, ObjectOf<T1>, match>>;
}
declare module "List/Either" {
    import { Index } from "Any/Index";
    import { Either as OEither } from "Object/Either";
    import { ObjectOf } from "List/ObjectOf";
    import { ListOf } from "Object/ListOf";
    import { List } from "List/List";
    import { True, Boolean } from "Boolean/Boolean";
    /** Split **`T`** into a [[Union]] with **`K`** keys in such a way that none of
     * the keys are ever present with one another within the different unions.
     * @param T to split
     * @param K to split with
     * @param strict to force excess property checks (?=`True`) https://github.com/microsoft/TypeScript/issues/20863
     * @returns [[Union]]
     * @example
     * ```ts
     * ```
     */
    export type Either<T extends List, K extends Index, strict extends Boolean = True> = OEither<ObjectOf<T>, K, strict> extends infer OE ? OE extends unknown ? ListOf<OE & {}> : never : never;
}
declare module "List/Exclude" {
    import { Match } from "Any/_Internal";
    import { ListOf } from "Object/ListOf";
    import { Exclude as OExclude } from "Object/Exclude";
    import { ObjectOf } from "List/ObjectOf";
    import { List } from "List/List";
    /** Exclude the entries of **`T1`** out of **`T`**
     * (If `match = 'default'`, no type checks are done)
     * @param T to remove from
     * @param T1 to remove out
     * @param match to change precision (?=`'default'`)
     * @returns **`any[]`**
     * @example
     * ```ts
     * ```
     */
    export type Exclude<T extends List, T1 extends List, match extends Match = 'default'> = ListOf<OExclude<ObjectOf<T>, ObjectOf<T1>, match>>;
}
declare module "List/ExcludeKeys" {
    import { ExcludeKeys as OExcludeKeys } from "Object/ExcludeKeys";
    import { Match } from "Any/_Internal";
    import { ObjectOf } from "List/ObjectOf";
    import { List } from "List/List";
    /** Exclude the keys of **`T1`** out of the keys of **`T`**
     * (If `match = 'default'`, no type checks are done)
     * @param T to remove the keys from
     * @param T1 to remove the keys out
     * @param match to change precision (?=`'default'`)
     * @returns **`keyof`**
     * @example
     * ```ts
     * ```
     */
    export type ExcludeKeys<T extends List, T1 extends List, match extends Match = 'default'> = OExcludeKeys<ObjectOf<T>, ObjectOf<T1>, match>;
}
declare module "List/Pick" {
    import { Pick as OPick } from "Object/Pick";
    import { ListOf } from "Object/ListOf";
    import { Index } from "Any/Index";
    import { ObjectOf } from "List/ObjectOf";
    import { List } from "List/List";
    /** Extract out of **`T`** the entries of key **`K`**
     * @param T to extract from
     * @param K to chose entries
     * @returns **`any[]`**
     * @example
     * ```ts
     * ```
     */
    export type Pick<T extends List, K extends Index> = ListOf<OPick<ObjectOf<T>, K>>;
}
declare module "List/Extract" {
    import { KeySet } from "List/KeySet";
    import { Number } from "Number/Number";
    import { Pick } from "List/Pick";
    import { List } from "List/List";
    /** Pick a range of entries (portion) from **`T`**
     * @param T to pick from
     * @param From to start with
     * @param To to end with
     * @returns **`any[]`**
     * @example
     * ```ts
     * ```
     */
    export type Extract<T extends List, From extends Number, To extends Number> = Pick<T, KeySet<From, To>>;
}
declare module "List/Filter" {
    import { Filter as OFilter } from "Object/Filter";
    import { ListOf } from "Object/ListOf";
    import { Match } from "Any/_Internal";
    import { ObjectOf } from "List/ObjectOf";
    import { List } from "List/List";
    /** Filter out of **`T`** the entries that match **`M`**
     * @param T to remove from
     * @param M to select entries
     * @param match to change precision (?=`'default'`)
     * @returns **`any[]`**
     * @example
     * ```ts
     * ```
     */
    export type Filter<T extends List, M extends any, match extends Match = 'default'> = ListOf<OFilter<ObjectOf<T>, M, match>>;
}
declare module "List/FilterKeys" {
    import { FilterKeys as OFilterKeys } from "Object/FilterKeys";
    import { Match } from "Any/_Internal";
    import { ObjectOf } from "List/ObjectOf";
    import { List } from "List/List";
    /** Filter out the keys of **`T`** which entries match **`M`**
     * @param T to remove from
     * @param M to select entries
     * @param match to change precision (?=`'default'`)
     * @returns **`keyof`**
     * @example
     * ```ts
     * ```
     */
    export type FilterKeys<T extends List, M extends any, match extends Match = 'default'> = OFilterKeys<ObjectOf<T>, M, match>;
}
declare module "List/UnNest" {
    import { Concat } from "List/Concat";
    import { Append } from "List/Append";
    import { Cast } from "Any/Cast";
    import { Length } from "List/Length";
    import { Iteration } from "Iteration/Iteration";
    import { IterationOf } from "Iteration/IterationOf";
    import { Next } from "Iteration/Next";
    import { Pos } from "Iteration/Pos";
    import { List } from "List/List";
    import { UnionOf } from "List/UnionOf";
    /**
     * @hidden
     */
    type _UnNestCheap<T extends List> = (UnionOf<T> extends infer UT ? UT extends unknown ? UT extends List ? UnionOf<UT> : UT : never : never)[] & {};
    /**
     * @hidden
     */
    type _UnNestExact<T extends List, TN extends List = [], I extends Iteration = IterationOf<'0'>> = {
        0: _UnNestExact<T, Concat<TN, T[Pos<I>]>, Next<I>>;
        1: _UnNestExact<T, Append<TN, T[Pos<I>]>, Next<I>>;
        2: TN;
    }[Pos<I> extends Length<T> ? 2 : T[Pos<I>] extends List ? 0 : 1];
    /**
     * @hidden
     */
    type _UnNest<T extends List> = number extends Length<T> ? _UnNestCheap<T> : _UnNestExact<T>;
    /** Remove a dimension of **`T`**
     * @param T to un-nest
     * @returns **`any[]`**
     * @example
     * ```ts
     * ```
     */
    export type UnNest<T extends List> = _UnNest<T> extends infer X ? Cast<X, List> : never;
}
declare module "List/Flatten" {
    import { List } from "List/List";
    import { UnNest } from "List/UnNest";
    import { Cast } from "Any/Cast";
    import { Equals } from "Any/Equals";
    import { False } from "Boolean/Boolean";
    /**
     * @hidden
     */
    type _Flatten<T extends List, TO extends List = []> = {
        0: _Flatten<UnNest<T>, T>;
        1: T;
    }[Equals<T, TO> extends False ? 0 : 1];
    /** Remove all dimensions of **`T`** (10 max)
     * @param T to un-nest
     * @returns **`any[]`**
     * @example
     * ```ts
     * ```
     */
    export type Flatten<T extends List> = _Flatten<T> extends infer X ? Cast<X, List> : never;
}
declare module "List/Take" {
    import { Number } from "Number/Number";
    import { IterationOf } from "Iteration/IterationOf";
    import { Iteration } from "Iteration/Iteration";
    import { Pos } from "Iteration/Pos";
    import { Next } from "Iteration/Next";
    import { Cast } from "Any/Cast";
    import { Reverse } from "List/Reverse";
    import { Prepend } from "List/Prepend";
    import { Key } from "Iteration/Key";
    import { Way } from "Iteration/_Internal";
    import { List } from "List/List";
    /**
     * @hidden
     */
    type _Take<T extends List, N extends Number, TN extends List = [], I extends Iteration = IterationOf<'0'>> = {
        0: _Take<T, N, Prepend<TN, T[Pos<I>]>, Next<I>>;
        1: TN;
    }[N extends Key<I> ? 1 : 0];
    /** Extract **`N`** entries out of **`T`**
     * @param T to extract from
     * @param N to extract out
     * @param way to extract from end (?='->')
     * @returns **`any[]`**
     * @example
     * ```ts
     * ```
     */
    export type Take<T extends List, N extends Number, way extends Way = '->'> = {
        '->': Reverse<_Take<T, N>>;
        '<-': _Take<Reverse<T>, N>;
    }[way] extends infer X ? Cast<X, List> : never;
}
declare module "List/Group" {
    import { Number } from "Number/Number";
    import { Drop } from "List/Drop";
    import { Take } from "List/Take";
    import { Cast } from "Any/Cast";
    import { Prepend } from "List/Prepend";
    import { Reverse } from "List/Reverse";
    import { List } from "List/List";
    /**
     * @hidden
     */
    type _Group<T extends List, N extends Number, TN extends List = []> = {
        0: _Group<Drop<T, N>, N, Prepend<TN, Take<T, N>>>;
        1: Reverse<TN>;
    }[T extends List<never> ? 1 : 0];
    /** Split **`T`** into sub-[[List]]s every **`N`**
     * @param T to group
     * @param N to split at
     * @returns **`any[]`**
     * @example
     * ```ts
     * ```
     */
    export type Group<T extends List, N extends Number> = _Group<T, N> extends infer X ? Cast<X, List> : never;
}
declare module "List/Has" {
    import { Match } from "Any/_Internal";
    import { Has as OHas } from "Object/Has";
    import { Index } from "Any/Index";
    import { ObjectOf } from "List/ObjectOf";
    import { List } from "List/List";
    /** Check whether **`T`** has a entry of key **`K`** that matches **`M`**
     * @param T to be inspected
     * @param K to choose entry
     * @param M to check entry type (?=`any`)
     * @param match to change precision (?=`'default'`)
     * @returns [[Boolean]]
     * @example
     * ```ts
     * ```
     */
    export type Has<T extends List, K extends Index, M extends any = any, match extends Match = 'default'> = OHas<ObjectOf<T>, K, M, match>;
}
declare module "List/HasPath" {
    import { HasPath as OHasPath } from "Object/HasPath";
    import { Match } from "Any/_Internal";
    import { Index } from "Any/Index";
    import { ObjectOf } from "List/ObjectOf";
    import { List } from "List/List";
    /** Check whether **`T`** has nested entries that match **`M`**
     * @param T to be inspected
     * @param Path to be followed
     * @param M to check entry type (?=`any`)
     * @param match to change precision (?=`'default'`)
     * @returns [[Boolean]]
     * @example
     * ```ts
     * ```
     */
    export type HasPath<T extends List, Path extends List<Index>, M extends any = any, match extends Match = 'default'> = OHasPath<ObjectOf<T>, Path, M, match>;
}
declare module "List/Includes" {
    import { Match } from "Any/_Internal";
    import { Includes as OIncludes } from "Object/Includes";
    import { ObjectOf } from "List/ObjectOf";
    import { List } from "List/List";
    /** Check whether **`T`** has entries that match **`M`**
     * @param T to be inspected
     * @param M to check entry type
     * @param match to change precision (?=`'default'`)
     * @returns [[Boolean]]
     * @example
     * ```ts
     * ```
     */
    export type Includes<T extends List, M extends any, match extends Match = 'default'> = OIncludes<ObjectOf<T>, M, match>;
}
declare module "List/Intersect" {
    import { Intersect as OIntersect } from "Object/Intersect";
    import { Match } from "Any/_Internal";
    import { ListOf } from "Object/ListOf";
    import { ObjectOf } from "List/ObjectOf";
    import { List } from "List/List";
    /** Get the intersecting entries of **`T`** & **`T1`**
     * (If `match = 'default'`, no type checks are done)
     * @param T to check similarities with
     * @param T1 to check similarities against
     * @returns **`any[]`**
     * @example
     * ```ts
     * ```
     */
    export type Intersect<T extends List, T1 extends List, match extends Match = 'default'> = ListOf<OIntersect<ObjectOf<T>, ObjectOf<T1>, match>>;
}
declare module "List/IntersectKeys" {
    import { Match } from "Any/_Internal";
    import { IntersectKeys as OIntersectKeys } from "Object/IntersectKeys";
    import { ObjectOf } from "List/ObjectOf";
    import { List } from "List/List";
    /** Get the intersecting entries of **`T`** & **`T1`**
     * (If `match = 'default'`, no type checks are done)
     * @param T to check similarities with
     * @param T1 to check similarities against
     * @returns **`keyof`**
     * @example
     * ```ts
     * ```
     */
    export type IntersectKeys<T extends List, T1 extends List, match extends Match = 'default'> = OIntersectKeys<ObjectOf<T>, T1, match>;
}
declare module "List/Longest" {
    import { Exclude } from "Union/Exclude";
    import { List } from "List/List";
    /** Get the longest [[List]] of **`T`** & **`T1`**
     * (**`T`** has priority if both lengths are equal)
     * @param T to compare length
     * @param T1 to compare length
     * @returns **`T`** or **`T1`**
     * @example
     * ```ts
     * ```
     */
    export type Longest<T extends List, T1 extends List> = [Exclude<keyof T1, keyof T>] extends [never] ? T : T1;
}
declare module "List/Merge" {
    import { Omit } from "Object/Omit";
    import { Merge as OMerge } from "Object/Merge";
    import { At } from "Object/At";
    import { Depth } from "Object/_Internal";
    import { ObjectOf } from "List/ObjectOf";
    import { ListOf } from "Object/ListOf";
    import { Length } from "List/Length";
    import { Kind } from "Any/Kind";
    import { List } from "List/List";
    /**
     * @hidden
     */
    type MergeFlat<T extends List, T1 extends List> = number extends Length<T | T1> ? (T | T1) extends (infer T)[] ? T[] : never : ListOf<OMerge<ObjectOf<T>, Omit<ObjectOf<T1>, keyof T>>>;
    /**
     * @hidden
     */
    type MergeDeep<O, O1> = Kind<(O | O1)> extends 'array' ? MergeFlat<O & [], O1 & []> extends infer M ? {
        [K in keyof M]: MergeDeep<M[K], At<O1 & [], K>>;
    } & {} : never : O;
    /** Complete the fields of **`O`** with the ones of **`O1`**
     * ('deep' option will skip any nullable object to be merged)
     * @param O to complete
     * @param O1 to copy from
     * @param depth to do it deeply (?=`'flat'`)
     * @returns **`object`**
     * @example
     * ```ts
     * ```
     */
    export type Merge<T extends List, T1 extends List, depth extends Depth = 'flat'> = {
        'flat': MergeFlat<T, T1>;
        'deep': MergeDeep<T, T1>;
    }[depth];
}
declare module "List/Modify" {
    import { At } from "List/At";
    import { Replace } from "Union/Replace";
    import { x } from "Any/x";
    import { Exclude } from "Union/Exclude";
    import { List } from "List/List";
    /** Modify **`T`** with **`TMod`** & the [[x]] placeholder
     * @param T to copy from
     * @param TMod to copy to
     * @returns **`any[]`**
     * @example
     * ```ts
     * ```
     */
    export type Modify<T extends List, TMod extends List> = {
        [K in keyof TMod]: Replace<TMod[K], x, Exclude<At<T, K>, undefined>>;
    } & {};
}
declare module "List/NonNullableKeys" {
    import { NonNullableKeys as ONonNullableKeys } from "Object/NonNullableKeys";
    import { ObjectOf } from "List/ObjectOf";
    import { List } from "List/List";
    /** Get the keys of **`T`** that are non-nullable
     * @param T
     * @returns **`keyof`**
     * @example
     * ```ts
     * ```
     */
    export type NonNullableKeys<T extends List> = ONonNullableKeys<ObjectOf<T>>;
}
declare module "List/Nullable" {
    import { Index } from "Any/Index";
    import { Cast } from "Any/Cast";
    import { Implements } from "Any/Implements";
    import { Depth } from "Object/_Internal";
    import { Nullable as ONullable } from "Object/Nullable";
    import { ListOf } from "Object/ListOf";
    import { ObjectOf } from "List/ObjectOf";
    import { List } from "List/List";
    /** Make some entries of **`T`** nullable (deeply or not)
     * @param T to make nullable
     * @param K to choose entries (?=`keyof O`)
     * @param depth to do it deeply (?=`'flat'`)
     * @returns **`any[]`**
     * @example
     * ```ts
     * ```
     */
    export type Nullable<T extends List, K extends Index = keyof T, depth extends Depth = 'flat'> = {
        1: Cast<ONullable<T, Index, depth>, List>;
        0: ListOf<ONullable<ObjectOf<T>, K, depth>>;
    }[Implements<keyof T, K>];
}
declare module "List/NullableKeys" {
    import { NullableKeys as ONullableKeys } from "Object/NullableKeys";
    import { ObjectOf } from "List/ObjectOf";
    import { List } from "List/List";
    /** Get the keys of **`T`** that are nullable
     * @param T
     * @returns **`keyof`**
     * @example
     * ```ts
     * ```
     */
    export type NullableKeys<T extends List> = ONullableKeys<ObjectOf<T>>;
}
declare module "List/OptionalKeys" {
    import { OptionalKeys as OOptionalKeys } from "Object/OptionalKeys";
    import { ObjectOf } from "List/ObjectOf";
    import { List } from "List/List";
    /** Get the keys of **`T`** that are optional
     * @param T
     * @returns **`keyof`**
     * @example
     * ```ts
     * ```
     */
    export type OptionalKeys<T extends List> = OOptionalKeys<ObjectOf<T>>;
}
declare module "List/Path" {
    import { Path as OPath } from "Object/Path";
    import { Index } from "Any/Index";
    import { List } from "List/List";
    /** Get in **`T`** the type of nested properties
     * @param T to be inspected
     * @param Path to be followed
     * @returns **`any`**
     * @example
     * ```ts
     * ```
     */
    export type Path<T extends List, Path extends List<Index>> = OPath<T, Path>;
}
declare module "List/Paths" {
    import { Paths as OPaths } from "Object/Paths";
    import { ObjectOf } from "List/ObjectOf";
    import { List } from "List/List";
    /** Get all the possible paths of **`T`**
     * (⚠️ this won't work with circular-refs)
     * @param T to be inspected
     * @returns **`string[]`**
     * @example
     * ```ts
     * ```
     */
    export type Paths<T extends List> = OPaths<ObjectOf<T>>;
}
declare module "List/PathUp" {
    import { PathUp as OPathUp } from "Object/PathUp";
    import { List } from "List/List";
    import { Index } from "Any/Index";
    /** Get in **`O`** the type of nested properties.
     * It is able to deal with nested [[Union]]s.
     * @param T to be inspected
     * @param Path to be followed
     * @returns **`any`**
     * @example
     * ```ts
     * ```
     */
    export type PathUp<O extends List, Path extends List<Index>> = OPathUp<O, Path>;
}
declare module "List/PathValid" {
    import { PathValid as OPathValid } from "Object/PathValid";
    import { Index } from "Any/Index";
    import { List } from "List/List";
    /** Replaces invalid parts of a path with `never`
     * @param T to be inspected
     * @param Path to be validated
     * @returns **`Index[]`**
     * @example
     * ```ts
     * import {A, T, O} from 'ts-toolbelt'
     *
     * // Get a property in an array `t` at any depth with `path`
     * // `A.Cast<P, T.PathValid<T, P>>` makes sure `path` is valid
     * const getAt = <
     * T extends L.List,
     * P extends L.List<A.Index>
     * >(t: T, path: A.Cast<P, T.PathValid<T, P>>): T.Path<T, P> => {
     *     let valueAt = t
     *
     *     for (const p of path)
     *         valueAt = valueAt[p]
     *
     *     return valueAt as any
     * }
     *
     * const test0 = getAt([[[1]]] as const, [0, 0] as const) // [1]
     * const test1 = getAt([[[1]]] as const, [1] as const)    // error
     * ```
     */
    export type PathValid<T extends List, Path extends List<Index>> = OPathValid<T, Path>;
}
declare module "List/Pop" {
    import { Omit } from "List/Omit";
    import { List } from "List/List";
    import { LastIndex } from "List/LastIndex";
    import { Required } from "List/Required";
    /** Remove the last element out of **`T`**
     * @param T to remove from
     * @returns **`any[]`**
     * @example
     * ```ts
     * ```
     */
    export type Pop<T extends List> = Omit<T, LastIndex<Required<T>, 's'>>;
}
declare module "List/Readonly" {
    import { Depth } from "Object/_Internal";
    import { Readonly as OReadonly } from "Object/Readonly";
    import { Cast } from "Any/Cast";
    import { List } from "List/List";
    /** Make **`T`** readonly (deeply or not)
     * @param T to make readonly
     * @param depth to do it deeply (?=`'flat'`)
     * @returns **`any[]`**
     * @example
     * ```ts
     * ```
     */
    export type Readonly<T extends List, depth extends Depth = 'flat'> = Cast<OReadonly<T, keyof T, depth>, List>;
}
declare module "List/ReadonlyKeys" {
    import { ReadonlyKeys as OReadonlyKeys } from "Object/ReadonlyKeys";
    import { ObjectOf } from "List/ObjectOf";
    import { List } from "List/List";
    /** Get the keys of **`T`** that are readonly
     * @param T
     * @returns **`keyof`**
     * @example
     * ```ts
     * ```
     */
    export type ReadonlyKeys<T extends List> = OReadonlyKeys<ObjectOf<T>>;
}
declare module "List/Remove" {
    import { Number } from "Number/Number";
    import { KeySet } from "List/KeySet";
    import { Omit } from "List/Omit";
    import { List } from "List/List";
    /** Remove out of **`T`** a range of entries
     * @param T to remove from
     * @param From to start with
     * @param To to end with
     * @returns **`any[]`**
     * @example
     * ```ts
     * ```
     */
    export type Remove<T extends List, From extends Number, To extends Number> = Omit<T, KeySet<From, To>>;
}
declare module "List/Replace" {
    import { Replace as OReplace } from "Object/Replace";
    import { Match } from "Any/_Internal";
    import { Cast } from "Any/Cast";
    import { List } from "List/List";
    /** Update with **`A`** the entries of **`T`** that match **`M`**
     * @param O to update
     * @param M to select fields
     * @param A to update with
     * @param match to change precision (?=`'default'`)
     * @returns **`any[]`**
     * @example
     * ```ts
     * ```
     */
    export type Replace<T extends List, M extends any, A extends any, match extends Match = 'default'> = Cast<OReplace<T, M, A, match>, List>;
}
declare module "List/RequiredKeys" {
    import { RequiredKeys as ORequiredKeys } from "Object/RequiredKeys";
    import { ObjectOf } from "List/ObjectOf";
    import { List } from "List/List";
    /** Get the keys of **`T`** that are readonly
     * @param T
     * @returns **`keyof`**
     * @example
     * ```ts
     * ```
     */
    export type RequiredKeys<T extends List> = ORequiredKeys<ObjectOf<T>>;
}
declare module "List/Select" {
    import { Match } from "Any/_Internal";
    import { Select as OSelect } from "Object/Select";
    import { ListOf } from "Object/ListOf";
    import { ObjectOf } from "List/ObjectOf";
    import { List } from "List/List";
    /** Extract the entries of **`T`** that match **`M`**
     * @param T to extract from
     * @param M to select entries
     * @param match to change precision (?=`'default'`)
     * @returns **`any[]`**
     * @example
     * ```ts
     * ```
     */
    export type Select<T extends List, M extends any, match extends Match = 'default'> = ListOf<OSelect<ObjectOf<T>, M, match>>;
}
declare module "List/SelectKeys" {
    import { Match } from "Any/_Internal";
    import { SelectKeys as OSelectKeys } from "Object/SelectKeys";
    import { ObjectOf } from "List/ObjectOf";
    import { List } from "List/List";
    /** Get the keys of **`T`** which entries match **`M`**
     * @param T to extract from
     * @param M to select entries
     * @param match to change precision (?=`'default'`)
     * @returns **`keyof`**
     * @example
     * ```ts
     * ```
     */
    export type SelectKeys<T extends List, M extends any, match extends Match = 'default'> = OSelectKeys<ObjectOf<T>, M, match>;
}
declare module "List/Unionize" {
    import { Index } from "Any/Index";
    import { Unionize as OUnionize } from "Object/Unionize";
    import { Cast } from "Any/Cast";
    import { List } from "List/List";
    /** Make the fields of **`T`** union the ones of **`T1`**
     * @param T to union from
     * @param T1 to union with
     * @param depth to do it deeply (?=`'flat'`)
     * @returns **`any[]`**
     * @example
     * ```ts
     * ```
     */
    export type Unionize<T extends List, T1 extends List, K extends Index = keyof T> = Cast<OUnionize<T, T1, K>, List>;
}
declare module "List/Writable" {
    import { Depth } from "Object/_Internal";
    import { Writable as OWritable } from "Object/Writable";
    import { Cast } from "Any/Cast";
    import { List } from "List/List";
    /** Make **`T`** writable (deeply or not)
     * @param T to make writable
     * @param depth to do it deeply (?=`'flat'`)
     * @returns **`any[]`**
     * @example
     * ```ts
     * ```
     */
    export type Writable<T extends List, depth extends Depth = 'flat'> = Cast<OWritable<T, keyof T, depth>, List>;
}
declare module "List/WritableKeys" {
    import { WritableKeys as OWritableKeys } from "Object/WritableKeys";
    import { ObjectOf } from "List/ObjectOf";
    import { List } from "List/List";
    /** Get the keys of **`O`** that are writable
     * @param O
     * @returns **`keyof`**
     * @example
     * ```ts
     * ```
     */
    export type WritableKeys<T extends List> = OWritableKeys<ObjectOf<T>>;
}
declare module "List/Zip" {
    import { IterationOf } from "Iteration/IterationOf";
    import { Iteration } from "Iteration/Iteration";
    import { Prepend } from "List/Prepend";
    import { Next } from "Iteration/Next";
    import { Length } from "List/Length";
    import { Pos } from "Iteration/Pos";
    import { Reverse } from "List/Reverse";
    import { Cast } from "Any/Cast";
    import { List } from "List/List";
    /**
     * @hidden
     */
    type _Zip<T extends List, T1 extends List, TN extends List = [], I extends Iteration = IterationOf<'0'>> = {
        0: _Zip<T, T1, Prepend<TN, [T[Pos<I>], T1[Pos<I>]]>, Next<I>>;
        1: Reverse<TN>;
    }[Pos<I> extends Length<T> ? 1 : 0];
    /** Pair up the entries of **`T`** with **`T1`**
     * @param T to pair up
     * @param T1 to pair up with
     * @returns **`any[]`**
     * @example
     * ```ts
     * ```
     */
    export type Zip<T extends List, T1 extends List> = _Zip<T, T1> extends infer X ? Cast<X, List> : never;
}
declare module "List/ZipObj" {
    import { Length } from "List/Length";
    import { Pos } from "Iteration/Pos";
    import { Next } from "Iteration/Next";
    import { IterationOf } from "Iteration/IterationOf";
    import { Iteration } from "Iteration/Iteration";
    import { Cast } from "Any/Cast";
    import { Merge } from "Object/Merge";
    import { Record } from "Object/Record";
    import { Index } from "Any/Index";
    import { List } from "List/List";
    /**
     * @hidden
     */
    type _ZipObj<TProp extends List<Index>, TField extends List, O extends object = {}, I extends Iteration = IterationOf<'0'>> = {
        0: _ZipObj<TProp, TField, Merge<O, Record<TProp[Pos<I>], TField[Pos<I>]>>, Next<I>>;
        1: O;
    }[Pos<I> extends Length<TProp> ? 1 : 0];
    /** Create an **`object`** from [[List]]s of keys & fields
     * @param TProps its keys
     * @param TFields its fields
     * @returns **`object`**
     * @example
     * ```ts
     * ```
     */
    export type ZipObj<TKeys extends List<Index>, TFields extends List> = _ZipObj<TKeys, TFields> extends infer X ? Cast<X, object> : never;
}
declare module "List/_api" {
    export { Append } from "List/Append";
    export { Assign } from "List/Assign";
    export { AssignUp } from "List/AssignUp";
    export { At } from "List/At";
    export { Compulsory } from "List/Compulsory";
    export { CompulsoryKeys } from "List/CompulsoryKeys";
    export { Concat } from "List/Concat";
    export { Diff } from "List/Diff";
    export { Drop } from "List/Drop";
    export { Either } from "List/Either";
    export { Exclude } from "List/Exclude";
    export { ExcludeKeys } from "List/ExcludeKeys";
    export { Extract } from "List/Extract";
    export { Filter } from "List/Filter";
    export { FilterKeys } from "List/FilterKeys";
    export { Flatten } from "List/Flatten";
    export { Group } from "List/Group";
    export { Has } from "List/Has";
    export { HasPath } from "List/HasPath";
    export { Head } from "List/Head";
    export { Includes } from "List/Includes";
    export { Intersect } from "List/Intersect";
    export { IntersectKeys } from "List/IntersectKeys";
    export { Keys } from "List/Keys";
    export { KeySet } from "List/KeySet";
    export { Last } from "List/Last";
    export { LastIndex } from "List/LastIndex";
    export { Length } from "List/Length";
    export { Longest } from "List/Longest";
    export { Merge } from "List/Merge";
    export { Modify } from "List/Modify";
    export { NonNullable } from "List/NonNullable";
    export { NonNullableKeys } from "List/NonNullableKeys";
    export { Nullable } from "List/Nullable";
    export { NullableKeys } from "List/NullableKeys";
    export { ObjectOf } from "List/ObjectOf";
    export { Omit } from "List/Omit";
    export { Optional } from "List/Optional";
    export { OptionalKeys } from "List/OptionalKeys";
    export { Overwrite } from "List/Overwrite";
    export { Path } from "List/Path";
    export { Paths } from "List/Paths";
    export { PathUp } from "List/PathUp";
    export { PathValid } from "List/PathValid";
    export { Pick } from "List/Pick";
    export { Pop } from "List/Pop";
    export { Prepend } from "List/Prepend";
    export { Readonly } from "List/Readonly";
    export { ReadonlyKeys } from "List/ReadonlyKeys";
    export { Remove } from "List/Remove";
    export { Repeat } from "List/Repeat";
    export { Replace } from "List/Replace";
    export { Required } from "List/Required";
    export { RequiredKeys } from "List/RequiredKeys";
    export { Reverse } from "List/Reverse";
    export { Select } from "List/Select";
    export { SelectKeys } from "List/SelectKeys";
    export { Tail } from "List/Tail";
    export { Take } from "List/Take";
    export { List } from "List/List";
    export { List as Tuple } from "List/List";
    export { Unionize } from "List/Unionize";
    export { UnionOf } from "List/UnionOf";
    export { UnNest } from "List/UnNest";
    export { Update } from "List/Update";
    export { Writable } from "List/Writable";
    export { WritableKeys } from "List/WritableKeys";
    export { Zip } from "List/Zip";
    export { ZipObj } from "List/ZipObj";
}
declare module "index" {
    import * as Test from "Test";
    import * as A from "Any/_api";
    import * as B from "Boolean/_api";
    import * as C from "Class/_api";
    import * as F from "Function/_api";
    import * as I from "Iteration/_api";
    import * as M from "Misc/_api";
    import * as N from "Number/_api";
    import * as O from "Object/_api";
    import * as S from "String/_api";
    import * as T from "List/_api";
    import * as L from "List/_api";
    import * as U from "Union/_api";
    import * as Any from "Any/_api";
    import * as Boolean from "Boolean/_api";
    import * as Class from "Class/_api";
    import * as Function from "Function/_api";
    import * as Iteration from "Iteration/_api";
    import * as Misc from "Misc/_api";
    import * as Number from "Number/_api";
    import * as Object from "Object/_api";
    import * as String from "String/_api";
    import * as Tuple from "List/_api";
    import * as List from "List/_api";
    import * as Union from "Union/_api";
    export { Test, A, Any, B, Boolean, C, Class, F, Function, I, Iteration, L, List, M, Misc, N, Number, O, Object, S, String, T, Tuple, U, Union, };
}

declare module 'ts-toolbelt' {
    import main = require('index');
    export = main;
}

